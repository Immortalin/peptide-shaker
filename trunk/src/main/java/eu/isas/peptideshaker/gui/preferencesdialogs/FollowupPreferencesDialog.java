package eu.isas.peptideshaker.gui.preferencesdialogs;

import com.compomics.util.experiment.biology.Peptide;
import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.experiment.massspectrometry.Precursor;
import com.compomics.util.experiment.massspectrometry.Spectrum;
import com.compomics.util.experiment.massspectrometry.SpectrumFactory;
import com.compomics.util.gui.dialogs.ProgressDialogX;
import com.compomics.util.gui.renderers.AlignedListCellRenderer;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import eu.isas.peptideshaker.preferences.SearchParameters;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.filechooser.FileFilter;

/**
 * This class will allow the user to generate spectrum information for follow up analysis
 *
 * @author Marc Vaudel
 * @author Harald Barsnes
 */
public class FollowupPreferencesDialog extends javax.swing.JDialog {

    /**
     * The main GUI
     */
    private PeptideShakerGUI peptideShakerGUI;
    /**
     * The spectrum factory
     */
    private SpectrumFactory spectrumFactory = SpectrumFactory.getInstance();
    /**
     * A simple progress dialog.
     */
    private static ProgressDialogX progressDialog;

    /** 
     * Creates a new FollowupPreferencesDialog.
     * 
     * @param peptideShakerGUI 
     */
    public FollowupPreferencesDialog(PeptideShakerGUI peptideShakerGUI) {
        super(peptideShakerGUI, true);
        this.peptideShakerGUI = peptideShakerGUI;
        initComponents();

        spectrumValidationCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        idSelectionCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        vendorCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));

        this.setLocationRelativeTo(peptideShakerGUI);
        setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        backgroundPanel = new javax.swing.JPanel();
        spectraPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        spectrumValidationCmb = new javax.swing.JComboBox();
        exportMgfButton = new javax.swing.JButton();
        inclusionListPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        miscleavedCheck = new javax.swing.JCheckBox();
        reactiveCheck = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        idSelectionCmb = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        vendorCmb = new javax.swing.JComboBox();
        inclusionListButton = new javax.swing.JButton();
        srmButton = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        isoformsCheck = new javax.swing.JCheckBox();
        isoformsUnrelatedCheck = new javax.swing.JCheckBox();
        unrelatedCheck = new javax.swing.JCheckBox();
        degeneratedCheck = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        rtWindow = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Export");
        setResizable(false);

        backgroundPanel.setBackground(new java.awt.Color(230, 230, 230));

        spectraPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Unassigned Spectra"));
        spectraPanel.setOpaque(false);

        jLabel1.setText("Spectra Matching To:");

        spectrumValidationCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Non-validated PSMs", "Non-validated peptides", "Non-validated proteins" }));

        exportMgfButton.setText("Export as MGF");
        exportMgfButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportMgfButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout spectraPanelLayout = new javax.swing.GroupLayout(spectraPanel);
        spectraPanel.setLayout(spectraPanelLayout);
        spectraPanelLayout.setHorizontalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(31, 31, 31)
                .addComponent(spectrumValidationCmb, 0, 419, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(exportMgfButton)
                .addContainerGap())
        );
        spectraPanelLayout.setVerticalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(exportMgfButton)
                    .addComponent(spectrumValidationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        inclusionListPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Inclusion Lists"));
        inclusionListPanel.setOpaque(false);

        jLabel2.setText("Ignored Peptides:");

        miscleavedCheck.setSelected(true);
        miscleavedCheck.setText("miscleaved peptides");
        miscleavedCheck.setIconTextGap(10);
        miscleavedCheck.setOpaque(false);

        reactiveCheck.setSelected(true);
        reactiveCheck.setText("reactive peptides");
        reactiveCheck.setIconTextGap(10);
        reactiveCheck.setOpaque(false);

        jLabel3.setText("Include Validated PSMs:");

        idSelectionCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "of all validated PSMs", "of validated PSMs of all validated peptides", "of validated PSMs of validated peptides of all validated proteins", "of validated PSMs of currently displayed peptides", "of validated PSMs of currently displayed proteins" }));

        jLabel4.setText("Format:");

        vendorCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Thermo", "ABI", "Bruker", "MassLynx" }));

        inclusionListButton.setText("Generate Inclusion List");
        inclusionListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inclusionListButtonActionPerformed(evt);
            }
        });

        srmButton.setText("Generate SRM Transitions");
        srmButton.setEnabled(false);

        jLabel5.setText("Ignored Proteins:");

        isoformsCheck.setText("isoforms");
        isoformsCheck.setIconTextGap(10);
        isoformsCheck.setOpaque(false);

        isoformsUnrelatedCheck.setText("isoforms - unrelated proteins");
        isoformsUnrelatedCheck.setIconTextGap(10);
        isoformsUnrelatedCheck.setOpaque(false);

        unrelatedCheck.setSelected(true);
        unrelatedCheck.setText("unrelated proteins");
        unrelatedCheck.setIconTextGap(10);
        unrelatedCheck.setOpaque(false);

        degeneratedCheck.setSelected(true);
        degeneratedCheck.setText("degenerated peptides");
        degeneratedCheck.setIconTextGap(10);
        degeneratedCheck.setOpaque(false);

        jLabel6.setText("Minimum RT Window:");

        rtWindow.setText("20");

        jLabel7.setText("s");

        javax.swing.GroupLayout inclusionListPanelLayout = new javax.swing.GroupLayout(inclusionListPanel);
        inclusionListPanel.setLayout(inclusionListPanelLayout);
        inclusionListPanelLayout.setHorizontalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(jLabel6)
                            .addComponent(jLabel3)
                            .addComponent(jLabel5))
                        .addGap(18, 18, 18)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel7)
                                .addGap(470, 470, 470))
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(idSelectionCmb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(isoformsCheck)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(isoformsUnrelatedCheck))
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(miscleavedCheck)
                                        .addGap(11, 11, 11)
                                        .addComponent(reactiveCheck)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 23, Short.MAX_VALUE)
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(degeneratedCheck)
                                        .addComponent(unrelatedCheck))
                                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(jLabel4)
                                        .addGap(18, 18, 18)
                                        .addComponent(vendorCmb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inclusionListPanelLayout.createSequentialGroup()
                        .addComponent(srmButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(inclusionListButton)))
                .addContainerGap())
        );

        inclusionListPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {inclusionListButton, srmButton});

        inclusionListPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {degeneratedCheck, isoformsCheck, isoformsUnrelatedCheck, miscleavedCheck, reactiveCheck, unrelatedCheck});

        inclusionListPanelLayout.setVerticalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(reactiveCheck)
                            .addComponent(miscleavedCheck)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(isoformsCheck)
                            .addComponent(isoformsUnrelatedCheck)
                            .addComponent(jLabel5))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)
                            .addComponent(jLabel6)))
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addComponent(degeneratedCheck)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(unrelatedCheck)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(idSelectionCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vendorCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel3))
                .addGap(18, 18, 18)
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(srmButton)
                    .addComponent(inclusionListButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout backgroundPanelLayout = new javax.swing.GroupLayout(backgroundPanel);
        backgroundPanel.setLayout(backgroundPanelLayout);
        backgroundPanelLayout.setHorizontalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(spectraPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(inclusionListPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        backgroundPanelLayout.setVerticalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(spectraPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inclusionListPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exportMgfButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportMgfButtonActionPerformed

        progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
        progressDialog.doNothingOnClose();

        final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

        new Thread(new Runnable() {

            public void run() {
                progressDialog.setIndeterminate(true);
                progressDialog.setTitle("Exporting. Please Wait...");
                progressDialog.setVisible(true);
            }
        }, "ProgressDialog").start();

        new Thread("SaveThread") {

            @Override
            public void run() {
                final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
                fileChooser.setDialogTitle("Select destination file");
                fileChooser.setMultiSelectionEnabled(false);

                FileFilter filter = new FileFilter() {

                    @Override
                    public boolean accept(File myFile) {
                        return myFile.isDirectory() || myFile.getName().endsWith(".mgf");
                    }

                    @Override
                    public String getDescription() {
                        return "(Mascot Generic File) *.mgf";
                    }
                };

                fileChooser.setFileFilter(filter);

                int returnVal = fileChooser.showSaveDialog(tempRef);

                if (returnVal == JFileChooser.APPROVE_OPTION) {

                    File outputFile = fileChooser.getSelectedFile();


                    int outcome = JOptionPane.YES_OPTION;

                    if (outputFile.exists()) {
                        outcome = JOptionPane.showConfirmDialog(tempRef,
                                "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                                JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                    }

                    if (outcome == JOptionPane.YES_OPTION) {

                        if (!outputFile.getName().endsWith(".mgf")) {
                            outputFile = new File(outputFile.getParent(), outputFile.getName() + ".mgf");
                        }

                        try {
                            progressDialog.setIndeterminate(false);
                            int total = 0;
                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                total += spectrumFactory.getSpectrumTitles(mgfFile).size();
                            }
                            progressDialog.setMax(total);
                            FileWriter f = new FileWriter(outputFile);
                            BufferedWriter b = new BufferedWriter(f);
                            String spectrumKey;
                            int cpt = 0;
                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                for (String spectrumTitle : spectrumFactory.getSpectrumTitles(mgfFile)) {
                                    spectrumKey = Spectrum.getSpectrumKey(mgfFile, spectrumTitle);
                                    if (!isValidated(spectrumKey)) {
                                        b.write(((MSnSpectrum) spectrumFactory.getSpectrum(spectrumKey)).asMgf());
                                    }
                                    cpt++;
                                    progressDialog.setValue(cpt);
                                }
                            }
                            b.close();
                            f.close();

                            JOptionPane.showMessageDialog(tempRef, "Spectra saved to " + outputFile + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception e) {
                            e.printStackTrace();
                            JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                        }
                    }
                }
                progressDialog.setVisible(false);
                progressDialog.dispose();
            }
        }.start();
    }//GEN-LAST:event_exportMgfButtonActionPerformed

    private void inclusionListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inclusionListButtonActionPerformed

        progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
        progressDialog.doNothingOnClose();

        final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

        new Thread(new Runnable() {

            public void run() {
                progressDialog.setIndeterminate(true);
                progressDialog.setTitle("Exporting. Please Wait...");
                progressDialog.setVisible(true);
            }
        }, "ProgressDialog").start();

        new Thread("SaveThread") {

            @Override
            public void run() {

                if (validateInput()) {
                    final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
                    fileChooser.setDialogTitle("Select destination file");
                    fileChooser.setMultiSelectionEnabled(false);

                    FileFilter filter = new FileFilter() {

                        @Override
                        public boolean accept(File myFile) {
                            if (vendorCmb.getSelectedIndex() == 2) {
                                return myFile.isDirectory() || myFile.getName().endsWith(".csv");
                            }
                            return myFile.isDirectory() || myFile.getName().endsWith(".txt");
                        }

                        @Override
                        public String getDescription() {
                            switch (vendorCmb.getSelectedIndex()) {
                                case 0:
                                    return "(Thermo inclusion list) .txt";
                                case 1:
                                    return "(ABI inclusion list) .txt";
                                case 2:
                                    return "(Bruker inclusion list) .csv";
                                case 3:
                                    return "(MassLynx inclusion list) .txt";
                                default:
                                    return "(unknown format) .txt";
                            }
                        }
                    };

                    fileChooser.setFileFilter(filter);

                    int returnVal = fileChooser.showSaveDialog(tempRef);

                    if (returnVal == JFileChooser.APPROVE_OPTION) {

                        File outputFile = fileChooser.getSelectedFile();


                        int outcome = JOptionPane.YES_OPTION;

                        if (outputFile.exists()) {
                            outcome = JOptionPane.showConfirmDialog(tempRef,
                                    "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                                    JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                        }

                        if (outcome == JOptionPane.YES_OPTION) {

                            if (vendorCmb.getSelectedIndex() == 2) {
                                if (!outputFile.getName().endsWith(".csv")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".csv");
                                }
                            } else {
                                if (!outputFile.getName().endsWith(".txt")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".txt");
                                }
                            }

                            try {
                                ArrayList<String> inspectedProteins;
                                if (idSelectionCmb.getSelectedIndex() == 4) {
                                    inspectedProteins = peptideShakerGUI.getDisplayedProteins();
                                } else {
                                    inspectedProteins = new ArrayList<String>(peptideShakerGUI.getIdentification().getProteinIdentification());
                                }
                                progressDialog.setIndeterminate(false);
                                progressDialog.setMax(inspectedProteins.size());
                                ArrayList<String> displayedPeptides = peptideShakerGUI.getDisplayedPeptides();
                                FileWriter f = new FileWriter(outputFile);
                                BufferedWriter b = new BufferedWriter(f);
                                PSParameter psParameter = new PSParameter();
                                ProteinMatch proteinMatch;
                                PeptideMatch peptideMatch;
                                int cpt = 0;
                                for (String proteinKey : inspectedProteins) {
                                    proteinMatch = peptideShakerGUI.getIdentification().getProteinMatch(proteinKey);
                                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, psParameter);
                                    if (idSelectionCmb.getSelectedIndex() == 0
                                            || idSelectionCmb.getSelectedIndex() == 1
                                            || idSelectionCmb.getSelectedIndex() == 3
                                            || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()) {
                                        for (String peptideKey : proteinMatch.getPeptideMatches()) {
                                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(peptideKey, psParameter);
                                            if (idSelectionCmb.getSelectedIndex() == 0
                                                    || idSelectionCmb.getSelectedIndex() == 1 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 3 && displayedPeptides.contains(peptideKey)) {
                                                peptideMatch = peptideShakerGUI.getIdentification().getPeptideMatch(peptideKey);
                                                if (!shallExclude(proteinKey, peptideMatch.getTheoreticPeptide())) {
                                                    ArrayList<Double> retentionTimes = new ArrayList<Double>();
                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {
                                                        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
                                                        retentionTimes.add(precursor.getRt());
                                                    }
                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {
                                                        psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);
                                                        if (psParameter.isValidated()) {
                                                            b.write(getInclusionListLine(spectrumKey, retentionTimes));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    cpt++;
                                    progressDialog.setValue(cpt);
                                }
                                b.close();
                                f.close();

                                JOptionPane.showMessageDialog(tempRef, "Inclusion list saved to " + fileChooser.getSelectedFile().getName() + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                            } catch (Exception e) {
                                e.printStackTrace();
                                JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                            }
                        }
                    }
                }
                progressDialog.setVisible(false);
                progressDialog.dispose();
            }
        }.start();
    }//GEN-LAST:event_inclusionListButtonActionPerformed

    /**
     * Indicates whether a spectrum is validated according to the user's settings.
     * @param spectrumKey   the key of the spectrum
     * @return a boolean indicating whether the spectrum is validated
     */
    private boolean isValidated(String spectrumKey) {
        PSParameter psParameter = new PSParameter();
        psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);
        switch (spectrumValidationCmb.getSelectedIndex()) {
            case 0:
                return psParameter.isValidated();
            case 1:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumMatch.getBestAssumption().getPeptide().getKey(), psParameter);
                    return psParameter.isValidated();
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            case 2:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    for (String protein : spectrumMatch.getBestAssumption().getPeptide().getParentProteins()) {
                        for (String proteinMatch : peptideShakerGUI.getIdentification().getProteinMap().get(protein)) {
                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinMatch, psParameter);
                            if (psParameter.isValidated()) {
                                return true;
                            }
                        }
                    }
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            default:
                return false;
        }
    }

    /**
     * Returns whether a peptide should be excluded from the inclusion list according to the GUI setting and the protein match it belongs to.
     * 
     * @param proteinMatch  the protein match this peptide belongs to
     * @param peptide       the peptide of interest
     * @return a boolean indicating whether this peptide should be excluded
     */
    private boolean shallExclude(String proteinKey, Peptide peptide) {
        if (miscleavedCheck.isSelected()
                && peptide.getNMissedCleavages(peptideShakerGUI.getSearchParameters().getEnzyme()) > 0) {
            return true;
        }
        if (reactiveCheck.isSelected()) {
            String sequence = peptide.getSequence();
            if (sequence.contains("M")
                    || sequence.contains("C")
                    || sequence.contains("W")
                    || sequence.contains("NG")
                    || sequence.contains("DG")
                    || sequence.contains("QG")
                    || sequence.startsWith("N")
                    || sequence.startsWith("Q")) {
                return true;
            }
        }
        if (isoformsCheck.isSelected() || isoformsUnrelatedCheck.isSelected() || unrelatedCheck.isSelected()) {
            PSParameter pSParameter = new PSParameter();
            pSParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, pSParameter);
            if (isoformsCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS) {
                return true;
            }
            if (isoformsUnrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS_UNRELATED) {
                return true;
            }
            if (unrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.UNRELATED) {
                return true;
            }
        }
        if (degeneratedCheck.isSelected()) {
            for (String protein : peptide.getParentProteins()) {
                if (!proteinKey.contains(protein)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Validates the user's input
     * @return a boolean indicating whether the input is valid.
     */
    private boolean validateInput() {
        try {
            double test = new Double(rtWindow.getText().trim());
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Please verify the input for the RT minimal window.", "Wrong input", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        return true;
    }

    /**
     * Returns a line to be output in an inclusion list according to the user's input
     * @param spectrumKey       The key of the spectrum
     * @param retentionTimes    The retention times found for this peptide
     * @return a line to be appended in the inclusion list
     * @throws Exception exception thrown whenever a problem was encountered while reading the spectrum file
     */
    private String getInclusionListLine(String spectrumKey, ArrayList<Double> retentionTimes) throws Exception {
        Collections.sort(retentionTimes);
        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
        double minWindow = new Double(rtWindow.getText().trim());
        switch (vendorCmb.getSelectedIndex()) {
            case 0:
                int index = (int) (0.25 * retentionTimes.size());
                double rtMin = retentionTimes.get(index) / 60;
                index = (int) (0.75 * retentionTimes.size());
                double rtMax = retentionTimes.get(index) / 60;
                if (rtMax - rtMin < minWindow / 60) {
                    index = (int) (0.5 * retentionTimes.size());
                    rtMin = (retentionTimes.get(index) - minWindow / 2) / 60;
                    rtMax = (retentionTimes.get(index) + minWindow / 2) / 60;
                }
                return precursor.getMz() + "\t" + rtMin + "\t" + rtMax + "\n";
            case 1:
                index = (int) (0.5 * retentionTimes.size());
                double rtInMin = retentionTimes.get(index) / 60;
                return rtInMin + "\t" + precursor.getMz() + "\n";
            case 2:
                index = (int) 0.5 * retentionTimes.size();
                double rt = retentionTimes.get(index);
                int index25 = (int) (0.25 * retentionTimes.size());
                int index75 = (int) (0.75 * retentionTimes.size());
                double range = retentionTimes.get(index75) - retentionTimes.get(index25);
                if (range < minWindow) {
                    range = minWindow;
                }
                if (peptideShakerGUI.getSearchParameters().getPrecursorToleranceUnit() == SearchParameters.PPM) {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorTolerance() / 1000000 * precursor.getMz();
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                } else {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorTolerance() / precursor.getCharge().value;
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                }
            case 3:
                index = (int) (0.5 * retentionTimes.size());
                rt = retentionTimes.get(index);
                return precursor.getMz() + "," + rt + "\n";
            default:
                return "";
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel backgroundPanel;
    private javax.swing.JCheckBox degeneratedCheck;
    private javax.swing.JButton exportMgfButton;
    private javax.swing.JComboBox idSelectionCmb;
    private javax.swing.JButton inclusionListButton;
    private javax.swing.JPanel inclusionListPanel;
    private javax.swing.JCheckBox isoformsCheck;
    private javax.swing.JCheckBox isoformsUnrelatedCheck;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JCheckBox miscleavedCheck;
    private javax.swing.JCheckBox reactiveCheck;
    private javax.swing.JTextField rtWindow;
    private javax.swing.JPanel spectraPanel;
    private javax.swing.JComboBox spectrumValidationCmb;
    private javax.swing.JButton srmButton;
    private javax.swing.JCheckBox unrelatedCheck;
    private javax.swing.JComboBox vendorCmb;
    // End of variables declaration//GEN-END:variables
}
