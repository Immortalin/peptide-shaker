
/*
 * FollowupPreferencesDialog.java
 *
 * Created on Aug 10, 2011, 6:07:10 PM
 */
package eu.isas.peptideshaker.gui.preferencesdialogs;

import com.compomics.util.experiment.biology.Peptide;
import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.experiment.massspectrometry.Precursor;
import com.compomics.util.experiment.massspectrometry.Spectrum;
import com.compomics.util.experiment.massspectrometry.SpectrumFactory;
import com.compomics.util.gui.dialogs.ProgressDialogX;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import eu.isas.peptideshaker.preferences.SearchParameters;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;

/**
 * This class will allow the user to generate spectrum information for follow up analysis
 *
 * @author Marc
 */
public class FollowupPreferencesDialog extends javax.swing.JDialog {

    /**
     * The main GUI
     */
    private PeptideShakerGUI peptideShakerGUI;
    /**
     * The spectrum factory
     */
    private SpectrumFactory spectrumFactory = SpectrumFactory.getInstance();
    /**
     * A simple progress dialog.
     */
    private static ProgressDialogX progressDialog;

    /** Creates new form FollowupPreferencesDialog */
    public FollowupPreferencesDialog(PeptideShakerGUI peptideShakerGUI) {
        super(peptideShakerGUI, true);
        this.peptideShakerGUI = peptideShakerGUI;
        initComponents();
        this.setLocationRelativeTo(peptideShakerGUI);
        setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        spectrumValidationCmb = new javax.swing.JComboBox();
        exportMgfButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        miscleavedCheck = new javax.swing.JCheckBox();
        reactiveCheck = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        idSelectionCmb = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        vendorCmb = new javax.swing.JComboBox();
        inclusionListButton = new javax.swing.JButton();
        mrmButton = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        isoformsCheck = new javax.swing.JCheckBox();
        isoformsUnrelatedCheck = new javax.swing.JCheckBox();
        unrelatedCheck = new javax.swing.JCheckBox();
        degeneratedCheck = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        rtWindow = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        exitButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Unassigned spectra"));

        jLabel1.setText("Spectra matching to:");

        spectrumValidationCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Non-validated PSMs", "Non-validated peptides", "Non-validated proteins" }));

        exportMgfButton.setText("Export as mgf");
        exportMgfButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportMgfButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(spectrumValidationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 297, Short.MAX_VALUE)
                .addComponent(exportMgfButton)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(spectrumValidationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(exportMgfButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Inclusion lists"));

        jLabel2.setText("Ignored peptides:");

        miscleavedCheck.setSelected(true);
        miscleavedCheck.setText("miscleaved peptides");

        reactiveCheck.setSelected(true);
        reactiveCheck.setText("reactive peptides");

        jLabel3.setText("Include validated PSMs:");

        idSelectionCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "of all validated PSMs", "of validated PSMs of all validated peptides", "of validated PSMs of validated peptides of all validated proteins", "of validated PSMs of currently displayed peptides", "of validated PSMs of currently displayed proteins" }));

        jLabel4.setText("Format:");

        vendorCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Thermo", "ABI", "Bruker", "MassLynx" }));

        inclusionListButton.setText("Generate Inclusion List");
        inclusionListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inclusionListButtonActionPerformed(evt);
            }
        });

        mrmButton.setText("Generate MRM transitions");
        mrmButton.setEnabled(false);

        jLabel5.setText("Ignored proteins:");

        isoformsCheck.setText("Isoforms");

        isoformsUnrelatedCheck.setText("Isoforms with unrelated proteins");

        unrelatedCheck.setSelected(true);
        unrelatedCheck.setText("unrelated proteins");

        degeneratedCheck.setSelected(true);
        degeneratedCheck.setText("degenerated peptides");

        jLabel6.setText("minimal RT window:");

        rtWindow.setText("20");

        jLabel7.setText("s");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addGap(18, 18, 18)
                        .addComponent(miscleavedCheck)
                        .addGap(18, 18, 18)
                        .addComponent(reactiveCheck)
                        .addGap(18, 18, 18)
                        .addComponent(degeneratedCheck))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addGap(18, 18, 18)
                        .addComponent(isoformsCheck)
                        .addGap(18, 18, 18)
                        .addComponent(isoformsUnrelatedCheck)
                        .addGap(18, 18, 18)
                        .addComponent(unrelatedCheck))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(111, 111, 111)
                        .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel7))
                    .addComponent(jLabel6)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addGap(18, 18, 18)
                                .addComponent(idSelectionCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(vendorCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 347, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(145, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(342, Short.MAX_VALUE)
                .addComponent(mrmButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inclusionListButton)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(miscleavedCheck)
                    .addComponent(reactiveCheck)
                    .addComponent(degeneratedCheck))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(isoformsCheck)
                    .addComponent(isoformsUnrelatedCheck)
                    .addComponent(unrelatedCheck))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(idSelectionCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(vendorCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(mrmButton)
                    .addComponent(inclusionListButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        exitButton.setText("Exit");
        exitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(exitButton, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(exitButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButtonActionPerformed
        dispose();
    }//GEN-LAST:event_exitButtonActionPerformed

    private void exportMgfButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportMgfButtonActionPerformed

        progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
        progressDialog.doNothingOnClose();

        final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

        new Thread(new Runnable() {

            public void run() {
                progressDialog.setIndeterminate(true);
                progressDialog.setTitle("Exporting. Please Wait...");
                progressDialog.setVisible(true);
            }
        }, "ProgressDialog").start();

        new Thread("SaveThread") {

            @Override
            public void run() {
                final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
                fileChooser.setDialogTitle("Select destination file");
                fileChooser.setMultiSelectionEnabled(false);

                FileFilter filter = new FileFilter() {

                    @Override
                    public boolean accept(File myFile) {
                        return myFile.isDirectory() || myFile.getName().endsWith(".mgf");
                    }

                    @Override
                    public String getDescription() {
                        return "(Mascot Generic File) *.mgf";
                    }
                };

                fileChooser.setFileFilter(filter);

                int returnVal = fileChooser.showSaveDialog(tempRef);

                if (returnVal == JFileChooser.APPROVE_OPTION) {

                    File outputFile = fileChooser.getSelectedFile();


                    int outcome = JOptionPane.YES_OPTION;

                    if (outputFile.exists()) {
                        outcome = JOptionPane.showConfirmDialog(tempRef,
                                "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                                JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                    }

                    if (outcome == JOptionPane.YES_OPTION) {

                        if (!outputFile.getName().endsWith(".mgf")) {
                            outputFile = new File(outputFile.getParent(), outputFile.getName() + ".mgf");
                        }

                        try {
                            progressDialog.setIndeterminate(false);
                            int total = 0;
                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                total += spectrumFactory.getSpectrumTitles(mgfFile).size();
                            }
                            progressDialog.setMax(total);
                            FileWriter f = new FileWriter(outputFile);
                            BufferedWriter b = new BufferedWriter(f);
                            String spectrumKey;
                            int cpt = 0;
                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                for (String spectrumTitle : spectrumFactory.getSpectrumTitles(mgfFile)) {
                                    spectrumKey = Spectrum.getSpectrumKey(mgfFile, spectrumTitle);
                                    if (!isValidated(spectrumKey)) {
                                        b.write(((MSnSpectrum) spectrumFactory.getSpectrum(spectrumKey)).asMgf());
                                    }
                                    cpt++;
                                    progressDialog.setValue(cpt);
                                }
                            }
                            b.close();
                            f.close();

                            JOptionPane.showMessageDialog(tempRef, "Spectra saved to " + outputFile + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception e) {
                            e.printStackTrace();
                            JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                        }
                    }
                }
                progressDialog.setVisible(false);
                progressDialog.dispose();
            }
        }.start();
    }//GEN-LAST:event_exportMgfButtonActionPerformed

    private void inclusionListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inclusionListButtonActionPerformed

        progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
        progressDialog.doNothingOnClose();

        final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

        new Thread(new Runnable() {

            public void run() {
                progressDialog.setIndeterminate(true);
                progressDialog.setTitle("Exporting. Please Wait...");
                progressDialog.setVisible(true);
            }
        }, "ProgressDialog").start();

        new Thread("SaveThread") {

            @Override
            public void run() {

                if (validateInput()) {
                    final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
                    fileChooser.setDialogTitle("Select destination file");
                    fileChooser.setMultiSelectionEnabled(false);

                    FileFilter filter = new FileFilter() {

                        @Override
                        public boolean accept(File myFile) {
                            if (vendorCmb.getSelectedIndex() == 2) {
                                return myFile.isDirectory() || myFile.getName().endsWith(".csv");
                            }
                            return myFile.isDirectory() || myFile.getName().endsWith(".txt");
                        }

                        @Override
                        public String getDescription() {
                            switch (vendorCmb.getSelectedIndex()) {
                                case 0:
                                    return "(Thermo inclusion list) .txt";
                                case 1:
                                    return "(ABI inclusion list) .txt";
                                case 2:
                                    return "(Bruker inclusion list) .csv";
                                case 3:
                                    return "(MassLynx inclusion list) .txt";
                                default:
                                    return "(unknown format) .txt";
                            }
                        }
                    };

                    fileChooser.setFileFilter(filter);

                    int returnVal = fileChooser.showSaveDialog(tempRef);

                    if (returnVal == JFileChooser.APPROVE_OPTION) {

                        File outputFile = fileChooser.getSelectedFile();


                        int outcome = JOptionPane.YES_OPTION;

                        if (outputFile.exists()) {
                            outcome = JOptionPane.showConfirmDialog(tempRef,
                                    "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                                    JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                        }

                        if (outcome == JOptionPane.YES_OPTION) {

                            if (vendorCmb.getSelectedIndex() == 2) {
                                if (!outputFile.getName().endsWith(".csv")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".csv");
                                }
                            } else {
                                if (!outputFile.getName().endsWith(".txt")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".txt");
                                }
                            }

                            try {
                                ArrayList<String> inspectedProteins;
                                if (idSelectionCmb.getSelectedIndex() == 4) {
                                    inspectedProteins = peptideShakerGUI.getDisplayedProteins();
                                } else {
                                    inspectedProteins = new ArrayList<String>(peptideShakerGUI.getIdentification().getProteinIdentification().keySet());
                                }
                                progressDialog.setIndeterminate(false);
                                progressDialog.setMax(inspectedProteins.size());
                                ArrayList<String> displayedPeptides = peptideShakerGUI.getDisplayedPeptides();
                                FileWriter f = new FileWriter(outputFile);
                                BufferedWriter b = new BufferedWriter(f);
                                PSParameter psParameter = new PSParameter();
                                ProteinMatch proteinMatch;
                                int cpt = 0;
                                for (String proteinKey : inspectedProteins) {
                                    proteinMatch = peptideShakerGUI.getIdentification().getProteinIdentification().get(proteinKey);
                                    psParameter = (PSParameter) proteinMatch.getUrParam(psParameter);
                                    if (idSelectionCmb.getSelectedIndex() == 0
                                            || idSelectionCmb.getSelectedIndex() == 1
                                            || idSelectionCmb.getSelectedIndex() == 3
                                            || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()) {
                                        for (PeptideMatch peptideMatch : proteinMatch.getPeptideMatches().values()) {
                                            psParameter = (PSParameter) peptideMatch.getUrParam(psParameter);
                                            if (idSelectionCmb.getSelectedIndex() == 0
                                                    || idSelectionCmb.getSelectedIndex() == 1 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 3 && displayedPeptides.contains(peptideMatch.getKey())) {
                                                if (!shallExclude(proteinMatch, peptideMatch.getTheoreticPeptide())) {
                                                    ArrayList<Double> retentionTimes = new ArrayList<Double>();
                                                    for (SpectrumMatch spectrumMatch : peptideMatch.getSpectrumMatches().values()) {
                                                        Precursor precursor = spectrumFactory.getPrecursor(spectrumMatch.getKey());
                                                        retentionTimes.add(precursor.getRt());
                                                    }
                                                    for (SpectrumMatch spectrumMatch : peptideMatch.getSpectrumMatches().values()) {
                                                        psParameter = (PSParameter) spectrumMatch.getUrParam(psParameter);
                                                        if (psParameter.isValidated()) {
                                                            b.write(getInclusionListLine(spectrumMatch.getKey(), retentionTimes));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    cpt++;
                                    progressDialog.setValue(cpt);
                                }
                                b.close();
                                f.close();

                                JOptionPane.showMessageDialog(tempRef, "Inclusion list saved to " + fileChooser.getSelectedFile().getName() + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                            } catch (Exception e) {
                                e.printStackTrace();
                                JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                            }
                        }
                    }
                }
                progressDialog.setVisible(false);
                progressDialog.dispose();
            }
        }.start();
    }//GEN-LAST:event_inclusionListButtonActionPerformed

    /**
     * Indicates whether a spectrum is validated according to the user's settings.
     * @param spectrumKey   the key of the spectrum
     * @return a boolean indicating whether the spectrum is validated
     */
    private boolean isValidated(String spectrumKey) {
        PSParameter psParameter = new PSParameter();
        SpectrumMatch match = peptideShakerGUI.getIdentification().getSpectrumIdentification().get(spectrumKey);
        if (match == null) {
            return false;
        }
        psParameter = (PSParameter) match.getUrParam(psParameter);
        switch (spectrumValidationCmb.getSelectedIndex()) {
            case 0:
                return psParameter.isValidated();
            case 1:
                if (!psParameter.isValidated()) {
                    return false;
                }
                PeptideMatch peptideMatch = peptideShakerGUI.getIdentification().getPeptideIdentification().get(
                        match.getBestAssumption().getPeptide().getKey());
                psParameter = (PSParameter) peptideMatch.getUrParam(psParameter);
                return psParameter.isValidated();
            case 2:
                if (!psParameter.isValidated()) {
                    return false;
                }
                for (Protein protein : match.getBestAssumption().getPeptide().getParentProteins()) {
                    for (ProteinMatch proteinMatch : peptideShakerGUI.getIdentification().getProteinMap().get(protein.getProteinKey())) {
                        psParameter = (PSParameter) proteinMatch.getUrParam(psParameter);
                        if (psParameter.isValidated()) {
                            return true;
                        }
                    }
                }
                return false;
            default:
                return false;
        }
    }

    /**
     * Returns whether a peptide should be excluded from the inclusion list according to the GUI setting and the protein match it belongs to.
     * 
     * @param proteinMatch  the protein match this peptide belongs to
     * @param peptide       the peptide of interest
     * @return a boolean indicating whether this peptide should be excluded
     */
    private boolean shallExclude(ProteinMatch proteinMatch, Peptide peptide) {
        if (miscleavedCheck.isSelected()
                && peptide.getNMissedCleavages(peptideShakerGUI.getSearchParameters().getEnzyme()) > 0) {
            return true;
        }
        if (reactiveCheck.isSelected()) {
            String sequence = peptide.getSequence();
            if (sequence.contains("M")
                    || sequence.contains("C")
                    || sequence.contains("W")
                    || sequence.contains("NG")
                    || sequence.contains("DG")
                    || sequence.contains("QG")
                    || sequence.startsWith("N")
                    || sequence.startsWith("Q")) {
                return true;
            }
        }
        if (isoformsCheck.isSelected() || isoformsUnrelatedCheck.isSelected() || unrelatedCheck.isSelected()) {
            PSParameter pSParameter = new PSParameter();
            pSParameter = (PSParameter) proteinMatch.getUrParam(pSParameter);
            if (isoformsCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS) {
                return true;
            }
            if (isoformsUnrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS_UNRELATED) {
                return true;
            }
            if (unrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.UNRELATED) {
                return true;
            }
        }
        if (degeneratedCheck.isSelected()) {
            for (Protein protein : peptide.getParentProteins()) {
                if (!proteinMatch.contains(protein)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Validates the user's input
     * @return a boolean indicating whether the input is valid.
     */
    private boolean validateInput() {
        try {
            double test = new Double(rtWindow.getText().trim());
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Please verify the input for the RT minimal window.", "Wrong input", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        return true;
    }

    /**
     * Returns a line to be output in an inclusion list according to the user's input
     * @param spectrumKey       The key of the spectrum
     * @param retentionTimes    The retention times found for this peptide
     * @return a line to be appended in the inclusion list
     * @throws Exception exception thrown whenever a problem was encountered while reading the spectrum file
     */
    private String getInclusionListLine(String spectrumKey, ArrayList<Double> retentionTimes) throws Exception {
        Collections.sort(retentionTimes);
        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
        double minWindow = new Double(rtWindow.getText().trim());
        switch (vendorCmb.getSelectedIndex()) {
            case 0:
                int index = (int) (0.25 * retentionTimes.size());
                double rtMin = retentionTimes.get(index) / 60;
                index = (int) (0.75 * retentionTimes.size());
                double rtMax = retentionTimes.get(index) / 60;
                if (rtMax - rtMin < minWindow / 60) {
                    index = (int) (0.5 * retentionTimes.size());
                    rtMin = (retentionTimes.get(index) - minWindow / 2) / 60;
                    rtMax = (retentionTimes.get(index) + minWindow / 2) / 60;
                }
                return precursor.getMz() + "\t" + rtMin + "\t" + rtMax + "\n";
            case 1:
                index = (int) (0.5 * retentionTimes.size());
                double rtInMin = retentionTimes.get(index) / 60;
                return rtInMin + "\t" + precursor.getMz() + "\n";
            case 2:
                index = (int) 0.5 * retentionTimes.size();
                double rt = retentionTimes.get(index);
                int index25 = (int) (0.25 * retentionTimes.size());
                int index75 = (int) (0.75 * retentionTimes.size());
                double range = retentionTimes.get(index75) - retentionTimes.get(index25);
                if (range < minWindow) {
                    range = minWindow;
                }
                if (peptideShakerGUI.getSearchParameters().getPrecursorToleranceUnit() == SearchParameters.PPM) {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorTolerance() / 1000000 * precursor.getMz();
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                } else {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorTolerance() / precursor.getCharge().value;
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                }
            case 3:
                index = (int) (0.5 * retentionTimes.size());
                rt = retentionTimes.get(index);
                return precursor.getMz() + "," + rt + "\n";
            default:
                return "";
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox degeneratedCheck;
    private javax.swing.JButton exitButton;
    private javax.swing.JButton exportMgfButton;
    private javax.swing.JComboBox idSelectionCmb;
    private javax.swing.JButton inclusionListButton;
    private javax.swing.JCheckBox isoformsCheck;
    private javax.swing.JCheckBox isoformsUnrelatedCheck;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JCheckBox miscleavedCheck;
    private javax.swing.JButton mrmButton;
    private javax.swing.JCheckBox reactiveCheck;
    private javax.swing.JTextField rtWindow;
    private javax.swing.JComboBox spectrumValidationCmb;
    private javax.swing.JCheckBox unrelatedCheck;
    private javax.swing.JComboBox vendorCmb;
    // End of variables declaration//GEN-END:variables
}
