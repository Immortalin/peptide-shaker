package eu.isas.peptideshaker.gui.preferencesdialogs;

import com.compomics.util.experiment.biology.Peptide;
import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.SequenceFactory;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.experiment.massspectrometry.Precursor;
import com.compomics.util.experiment.massspectrometry.Spectrum;
import com.compomics.util.experiment.massspectrometry.SpectrumFactory;
import com.compomics.util.gui.dialogs.ProgressDialogX;
import com.compomics.util.gui.renderers.AlignedListCellRenderer;
import eu.isas.peptideshaker.export.FeaturesGenerator;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import eu.isas.peptideshaker.preferences.SearchParameters;
import java.awt.Toolkit;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.filechooser.FileFilter;

/**
 * This class will allow the user to generate spectrum information for follow up analysis
 *
 * @author Marc Vaudel
 * @author Harald Barsnes
 */
public class FollowupPreferencesDialog extends javax.swing.JDialog {

    /**
     * The main GUI
     */
    private PeptideShakerGUI peptideShakerGUI;
    /**
     * The spectrum factory
     */
    private SpectrumFactory spectrumFactory = SpectrumFactory.getInstance();
    /**
     * A simple progress dialog.
     */
    private static ProgressDialogX progressDialog;

    /** 
     * Creates a new FollowupPreferencesDialog.
     * 
     * @param peptideShakerGUI 
     */
    public FollowupPreferencesDialog(PeptideShakerGUI peptideShakerGUI) {
        super(peptideShakerGUI, true);
        this.peptideShakerGUI = peptideShakerGUI;
        initComponents();

        spectrumValidationCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        idSelectionCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        vendorCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));

        this.setLocationRelativeTo(peptideShakerGUI);
        setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        backgroundPanel = new javax.swing.JPanel();
        spectraPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        spectrumValidationCmb = new javax.swing.JComboBox();
        exportMgfButton = new javax.swing.JButton();
        inclusionListPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        miscleavedCheck = new javax.swing.JCheckBox();
        reactiveCheck = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        idSelectionCmb = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        vendorCmb = new javax.swing.JComboBox();
        inclusionListButton = new javax.swing.JButton();
        srmButton = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        isoformsCheck = new javax.swing.JCheckBox();
        isoformsUnrelatedCheck = new javax.swing.JCheckBox();
        unrelatedCheck = new javax.swing.JCheckBox();
        degeneratedCheck = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        rtWindow = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        progenesisPanel = new javax.swing.JPanel();
        exportProgenesisButton = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        unidentifiedProteinsPanel = new javax.swing.JPanel();
        jLabel10 = new javax.swing.JLabel();
        exportUnidentifiedSpectraButton = new javax.swing.JButton();
        includeNonValidatedCheckBox = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Export");
        setResizable(false);

        backgroundPanel.setBackground(new java.awt.Color(230, 230, 230));

        spectraPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Unassigned Spectra"));
        spectraPanel.setOpaque(false);

        jLabel1.setText("Spectra Matching To:");

        spectrumValidationCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Non-Validated PSMs", "Non-Validated Peptides", "Non-Validated Proteins" }));

        exportMgfButton.setText("Export as MGF");
        exportMgfButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportMgfButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout spectraPanelLayout = new javax.swing.GroupLayout(spectraPanel);
        spectraPanel.setLayout(spectraPanelLayout);
        spectraPanelLayout.setHorizontalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(31, 31, 31)
                .addComponent(spectrumValidationCmb, 0, 422, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(exportMgfButton)
                .addContainerGap())
        );
        spectraPanelLayout.setVerticalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(exportMgfButton)
                    .addComponent(spectrumValidationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        inclusionListPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Inclusion Lists"));
        inclusionListPanel.setOpaque(false);

        jLabel2.setText("Ignored Peptides:");

        miscleavedCheck.setSelected(true);
        miscleavedCheck.setText("miscleaved peptides");
        miscleavedCheck.setIconTextGap(10);
        miscleavedCheck.setOpaque(false);

        reactiveCheck.setSelected(true);
        reactiveCheck.setText("reactive peptides");
        reactiveCheck.setIconTextGap(10);
        reactiveCheck.setOpaque(false);

        jLabel3.setText("Include Validated PSMs:");

        idSelectionCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "All Validated PSMs", "Validated PSMs of All Validated Peptides", "Validated PSMs of Validated Peptides of All Validated Proteins", "Validated PSMs of Currently Displayed Peptides", "Validated PSMs of Currently Displayed Proteins" }));

        jLabel4.setText("Format:");

        vendorCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Thermo", "ABI", "Bruker", "MassLynx" }));

        inclusionListButton.setText("Generate Inclusion List");
        inclusionListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inclusionListButtonActionPerformed(evt);
            }
        });

        srmButton.setText("Generate SRM Transitions");
        srmButton.setEnabled(false);
        srmButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                srmButtonActionPerformed(evt);
            }
        });

        jLabel5.setText("Ignored Proteins:");

        isoformsCheck.setText("isoforms");
        isoformsCheck.setIconTextGap(10);
        isoformsCheck.setOpaque(false);

        isoformsUnrelatedCheck.setText("isoforms - unrelated proteins");
        isoformsUnrelatedCheck.setIconTextGap(10);
        isoformsUnrelatedCheck.setOpaque(false);

        unrelatedCheck.setSelected(true);
        unrelatedCheck.setText("unrelated proteins");
        unrelatedCheck.setIconTextGap(10);
        unrelatedCheck.setOpaque(false);

        degeneratedCheck.setSelected(true);
        degeneratedCheck.setText("degenerated peptides");
        degeneratedCheck.setIconTextGap(10);
        degeneratedCheck.setOpaque(false);

        jLabel6.setText("Minimum RT Window:");

        rtWindow.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        rtWindow.setText("20");

        jLabel7.setText("s");

        javax.swing.GroupLayout inclusionListPanelLayout = new javax.swing.GroupLayout(inclusionListPanel);
        inclusionListPanel.setLayout(inclusionListPanelLayout);
        inclusionListPanelLayout.setHorizontalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(jLabel6)
                            .addComponent(jLabel3)
                            .addComponent(jLabel5))
                        .addGap(18, 18, 18)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel7)
                                .addGap(470, 470, 470))
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(idSelectionCmb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(isoformsCheck)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(isoformsUnrelatedCheck))
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(miscleavedCheck)
                                        .addGap(11, 11, 11)
                                        .addComponent(reactiveCheck)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 26, Short.MAX_VALUE)
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(degeneratedCheck)
                                        .addComponent(unrelatedCheck))
                                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                        .addComponent(jLabel4)
                                        .addGap(18, 18, 18)
                                        .addComponent(vendorCmb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inclusionListPanelLayout.createSequentialGroup()
                        .addComponent(srmButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(inclusionListButton)))
                .addContainerGap())
        );

        inclusionListPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {inclusionListButton, srmButton});

        inclusionListPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {degeneratedCheck, isoformsCheck, isoformsUnrelatedCheck, miscleavedCheck, reactiveCheck, unrelatedCheck});

        inclusionListPanelLayout.setVerticalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(reactiveCheck)
                            .addComponent(miscleavedCheck)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(isoformsCheck)
                            .addComponent(isoformsUnrelatedCheck)
                            .addComponent(jLabel5))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)
                            .addComponent(jLabel6)))
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addComponent(degeneratedCheck)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(unrelatedCheck)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(idSelectionCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vendorCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel3))
                .addGap(18, 18, 18)
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(srmButton)
                    .addComponent(inclusionListButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        progenesisPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Progenesis Export"));
        progenesisPanel.setOpaque(false);

        exportProgenesisButton.setText("Progenesis Tab Separated Phenyx Format");
        exportProgenesisButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportProgenesisButtonActionPerformed(evt);
            }
        });

        jLabel8.setText("Spectrum IDs To:");

        jLabel9.setFont(new java.awt.Font("Tahoma", 2, 11));
        jLabel9.setForeground(new java.awt.Color(255, 0, 0));
        jLabel9.setText("Under Development");

        javax.swing.GroupLayout progenesisPanelLayout = new javax.swing.GroupLayout(progenesisPanel);
        progenesisPanel.setLayout(progenesisPanelLayout);
        progenesisPanelLayout.setHorizontalGroup(
            progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(progenesisPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel8)
                .addGap(50, 50, 50)
                .addComponent(exportProgenesisButton, javax.swing.GroupLayout.DEFAULT_SIZE, 420, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 105, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        progenesisPanelLayout.setVerticalGroup(
            progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(progenesisPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(exportProgenesisButton)
                    .addComponent(jLabel8)
                    .addComponent(jLabel9))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        unidentifiedProteinsPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Unidentified Proteins"));
        unidentifiedProteinsPanel.setOpaque(false);

        jLabel10.setText("Export all the unidentified protein accession numbers to a tab separated text file:");

        exportUnidentifiedSpectraButton.setText("Export as CSV");
        exportUnidentifiedSpectraButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportUnidentifiedSpectraButtonActionPerformed(evt);
            }
        });

        includeNonValidatedCheckBox.setSelected(true);
        includeNonValidatedCheckBox.setText("Include Non-Validated");
        includeNonValidatedCheckBox.setToolTipText("Include non-validated protein identification");
        includeNonValidatedCheckBox.setIconTextGap(10);
        includeNonValidatedCheckBox.setOpaque(false);

        javax.swing.GroupLayout unidentifiedProteinsPanelLayout = new javax.swing.GroupLayout(unidentifiedProteinsPanel);
        unidentifiedProteinsPanel.setLayout(unidentifiedProteinsPanelLayout);
        unidentifiedProteinsPanelLayout.setHorizontalGroup(
            unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel10)
                .addGap(18, 18, 18)
                .addComponent(includeNonValidatedCheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                .addComponent(exportUnidentifiedSpectraButton)
                .addContainerGap())
        );
        unidentifiedProteinsPanelLayout.setVerticalGroup(
            unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel10)
                    .addComponent(exportUnidentifiedSpectraButton)
                    .addComponent(includeNonValidatedCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout backgroundPanelLayout = new javax.swing.GroupLayout(backgroundPanel);
        backgroundPanel.setLayout(backgroundPanelLayout);
        backgroundPanelLayout.setHorizontalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(spectraPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(unidentifiedProteinsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(progenesisPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(inclusionListPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        backgroundPanelLayout.setVerticalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(spectraPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(unidentifiedProteinsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progenesisPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inclusionListPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exportMgfButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportMgfButtonActionPerformed

        JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
        fileChooser.setDialogTitle("Select Destination File");
        fileChooser.setMultiSelectionEnabled(false);

        FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File myFile) {
                return myFile.isDirectory() || myFile.getName().endsWith(".mgf");
            }

            @Override
            public String getDescription() {
                return "(Mascot Generic File) *.mgf";
            }
        };

        fileChooser.setFileFilter(filter);

        int returnVal = fileChooser.showSaveDialog(this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {

            File outputFile = fileChooser.getSelectedFile();
            int outcome = JOptionPane.YES_OPTION;

            if (outputFile.exists()) {
                outcome = JOptionPane.showConfirmDialog(this,
                        "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            }

            if (outcome == JOptionPane.YES_OPTION) {

                if (!outputFile.getName().endsWith(".mgf")) {
                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".mgf");
                }

                final File finalOutputFile = outputFile;

                progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
                progressDialog.doNothingOnClose();

                final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

                new Thread(new Runnable() {

                    public void run() {
                        progressDialog.setIndeterminate(true);
                        progressDialog.setTitle("Exporting. Please Wait...");
                        progressDialog.setVisible(true);
                    }
                }, "ProgressDialog").start();

                new Thread("SaveThread") {

                    @Override
                    public void run() {

                        try {
                            // change the peptide shaker icon to a "waiting version"
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                            progressDialog.setIndeterminate(false);
                            int total = 0;
                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                total += spectrumFactory.getSpectrumTitles(mgfFile).size();
                            }
                            progressDialog.setMax(total);

                            FileWriter f = new FileWriter(finalOutputFile);
                            BufferedWriter b = new BufferedWriter(f);

                            for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                                for (String spectrumTitle : spectrumFactory.getSpectrumTitles(mgfFile)) {
                                    String spectrumKey = Spectrum.getSpectrumKey(mgfFile, spectrumTitle);
                                    if (!isValidated(spectrumKey)) {
                                        b.write(((MSnSpectrum) spectrumFactory.getSpectrum(spectrumKey)).asMgf());
                                    }
                                    progressDialog.incrementValue();
                                }
                            }

                            b.close();
                            f.close();

                            progressDialog.setVisible(false);
                            progressDialog.dispose();

                            // change the peptide shaker icon back to the default version
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                            JOptionPane.showMessageDialog(tempRef, "Spectra saved to " + finalOutputFile + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception e) {
                            // change the peptide shaker icon back to the default version
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                            e.printStackTrace();
                            JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                        }

                        if (progressDialog != null) {
                            progressDialog.setVisible(false);
                            progressDialog.dispose();
                        }
                    }
                }.start();
            }
        }
    }//GEN-LAST:event_exportMgfButtonActionPerformed
    private void inclusionListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inclusionListButtonActionPerformed

        progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
        progressDialog.doNothingOnClose();

        final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

        new Thread(new Runnable() {

            public void run() {
                progressDialog.setIndeterminate(true);
                progressDialog.setTitle("Exporting. Please Wait...");
                progressDialog.setVisible(true);
            }
        }, "ProgressDialog").start();

        new Thread("SaveThread") {

            @Override
            public void run() {

                if (validateInput()) {
                    final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
                    fileChooser.setDialogTitle("Select destination file");
                    fileChooser.setMultiSelectionEnabled(false);

                    FileFilter filter = new FileFilter() {

                        @Override
                        public boolean accept(File myFile) {
                            if (vendorCmb.getSelectedIndex() == 2) {
                                return myFile.isDirectory() || myFile.getName().endsWith(".csv");
                            }
                            return myFile.isDirectory() || myFile.getName().endsWith(".txt");
                        }

                        @Override
                        public String getDescription() {
                            switch (vendorCmb.getSelectedIndex()) {
                                case 0:
                                    return "(Thermo inclusion list) .txt";
                                case 1:
                                    return "(ABI inclusion list) .txt";
                                case 2:
                                    return "(Bruker inclusion list) .csv";
                                case 3:
                                    return "(MassLynx inclusion list) .txt";
                                default:
                                    return "(unknown format) .txt";
                            }
                        }
                    };

                    fileChooser.setFileFilter(filter);

                    int returnVal = fileChooser.showSaveDialog(tempRef);

                    if (returnVal == JFileChooser.APPROVE_OPTION) {

                        File outputFile = fileChooser.getSelectedFile();


                        int outcome = JOptionPane.YES_OPTION;

                        if (outputFile.exists()) {
                            outcome = JOptionPane.showConfirmDialog(tempRef,
                                    "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                                    JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                        }

                        if (outcome == JOptionPane.YES_OPTION) {

                            if (vendorCmb.getSelectedIndex() == 2) {
                                if (!outputFile.getName().endsWith(".csv")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".csv");
                                }
                            } else {
                                if (!outputFile.getName().endsWith(".txt")) {
                                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".txt");
                                }
                            }

                            try {

                                // change the peptide shaker icon to a "waiting version"
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                                ArrayList<String> inspectedProteins;
                                if (idSelectionCmb.getSelectedIndex() == 4) {
                                    inspectedProteins = peptideShakerGUI.getDisplayedProteins();
                                } else {
                                    inspectedProteins = new ArrayList<String>(peptideShakerGUI.getIdentification().getProteinIdentification());
                                }
                                progressDialog.setIndeterminate(false);
                                progressDialog.setMax(inspectedProteins.size());
                                ArrayList<String> displayedPeptides = peptideShakerGUI.getDisplayedPeptides();
                                FileWriter f = new FileWriter(outputFile);
                                BufferedWriter b = new BufferedWriter(f);
                                PSParameter psParameter = new PSParameter();
                                ProteinMatch proteinMatch;
                                PeptideMatch peptideMatch;
                                int cpt = 0;
                                for (String proteinKey : inspectedProteins) {
                                    proteinMatch = peptideShakerGUI.getIdentification().getProteinMatch(proteinKey);
                                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, psParameter);
                                    if (idSelectionCmb.getSelectedIndex() == 0
                                            || idSelectionCmb.getSelectedIndex() == 1
                                            || idSelectionCmb.getSelectedIndex() == 3
                                            || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()) {
                                        for (String peptideKey : proteinMatch.getPeptideMatches()) {
                                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(peptideKey, psParameter);
                                            if (idSelectionCmb.getSelectedIndex() == 0
                                                    || idSelectionCmb.getSelectedIndex() == 1 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 3 && displayedPeptides.contains(peptideKey)) {
                                                peptideMatch = peptideShakerGUI.getIdentification().getPeptideMatch(peptideKey);
                                                if (!shallExclude(proteinKey, peptideMatch.getTheoreticPeptide())) {
                                                    ArrayList<Double> retentionTimes = new ArrayList<Double>();
                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {
                                                        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
                                                        retentionTimes.add(precursor.getRt());
                                                    }
                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {
                                                        psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);
                                                        if (psParameter.isValidated()) {
                                                            b.write(getInclusionListLine(spectrumKey, retentionTimes));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    cpt++;
                                    progressDialog.setValue(cpt);
                                }
                                b.close();
                                f.close();

                                progressDialog.setVisible(false);
                                progressDialog.dispose();

                                // change the peptide shaker icon back to the default version
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                                JOptionPane.showMessageDialog(tempRef, "Inclusion list saved to " + fileChooser.getSelectedFile().getName() + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                            } catch (Exception e) {
                                // change the peptide shaker icon back to the default version
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                                e.printStackTrace();
                                JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                            }
                        }
                    }
                }
                if (progressDialog != null) {
                    progressDialog.setVisible(false);
                    progressDialog.dispose();
                }
            }
        }.start();
    }//GEN-LAST:event_inclusionListButtonActionPerformed

    /**
     * Export the Spectrum IDs as a Phenyx tab separated text file for input 
     * to Progenesis. Only works if the mgf files came from Progenesis in 
     * the first place.
     * 
     * @param evt 
     */
    private void exportProgenesisButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportProgenesisButtonActionPerformed

        JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
        fileChooser.setDialogTitle("Select Destination File");
        fileChooser.setMultiSelectionEnabled(false);

        FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File myFile) {
                return myFile.isDirectory() || myFile.getName().endsWith(".txt");
            }

            @Override
            public String getDescription() {
                return "(Tab Separated Text File) *.txt";
            }
        };

        fileChooser.setFileFilter(filter);

        int returnVal = fileChooser.showSaveDialog(this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {

            File outputFile = fileChooser.getSelectedFile();
            int outcome = JOptionPane.YES_OPTION;

            if (outputFile.exists()) {
                outcome = JOptionPane.showConfirmDialog(this,
                        "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            }

            if (outcome == JOptionPane.YES_OPTION) {

                if (!outputFile.getName().endsWith(".txt")) {
                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".txt");
                }

                final File finalOutputFile = outputFile;

                progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
                progressDialog.doNothingOnClose();

                final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

                new Thread(new Runnable() {

                    public void run() {
                        progressDialog.setIndeterminate(true);
                        progressDialog.setTitle("Exporting. Please Wait...");
                        progressDialog.setVisible(true);
                    }
                }, "ProgressDialog").start();

                new Thread("ExoportThread") {

                    @Override
                    public void run() {

                        try {
                            progressDialog.setIndeterminate(true);
                            progressDialog.setTitle("Exporting. Please Wait...");

                            FileWriter f = new FileWriter(finalOutputFile);
                            BufferedWriter b = new BufferedWriter(f);
                            
                            FeaturesGenerator outputGenerator = new FeaturesGenerator(peptideShakerGUI);
                            outputGenerator.getPSMsProgenesisExport(progressDialog, null, b);

                            b.close();
                            f.close();

                            progressDialog.setVisible(false);
                            progressDialog.dispose();

                            JOptionPane.showMessageDialog(tempRef, "Results exported to \'" + finalOutputFile.getName() + "\'.", "Export Complete", JOptionPane.INFORMATION_MESSAGE);

                        } catch (IOException e) {
                            JOptionPane.showMessageDialog(tempRef, "An error occured when exporting.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                            e.printStackTrace();
                        } catch (Exception e) {
                            JOptionPane.showMessageDialog(tempRef, "An error occured when exporting.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                            e.printStackTrace();
                        }

                        if (progressDialog != null) {
                            progressDialog.setVisible(false);
                            progressDialog.dispose();
                        }
                    }
                }.start();
            }
        }

    }//GEN-LAST:event_exportProgenesisButtonActionPerformed

    /**
     * Export SRM transitinos. Not yet implemented
     * 
     * @param evt 
     */
    private void srmButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_srmButtonActionPerformed
        // @TODO: implement me!!
    }//GEN-LAST:event_srmButtonActionPerformed

    /**
     * Export all the unidentified protein accession numbers to a tab separated text file.
     * 
     * @param evt 
     */
    private void exportUnidentifiedSpectraButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportUnidentifiedSpectraButtonActionPerformed

        JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
        fileChooser.setDialogTitle("Select Destination File");
        fileChooser.setMultiSelectionEnabled(false);

        FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File myFile) {
                return myFile.isDirectory() || myFile.getName().endsWith(".txt");
            }

            @Override
            public String getDescription() {
                return "(Tab Separated Text File) *.txt";
            }
        };

        fileChooser.setFileFilter(filter);

        int returnVal = fileChooser.showSaveDialog(this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {

            File outputFile = fileChooser.getSelectedFile();
            int outcome = JOptionPane.YES_OPTION;

            if (outputFile.exists()) {
                outcome = JOptionPane.showConfirmDialog(this,
                        "Should " + outputFile + " be overwritten?", "Selected File Already Exists",
                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            }

            if (outcome == JOptionPane.YES_OPTION) {

                if (!outputFile.getName().endsWith(".txt")) {
                    outputFile = new File(outputFile.getParent(), outputFile.getName() + ".txt");
                }

                final File finalOutputFile = outputFile;

                progressDialog = new ProgressDialogX(peptideShakerGUI, peptideShakerGUI, true);
                progressDialog.doNothingOnClose();

                final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

                new Thread(new Runnable() {

                    public void run() {
                        progressDialog.setIndeterminate(true);
                        progressDialog.setTitle("Exporting. Please Wait...");
                        progressDialog.setVisible(true);
                    }
                }, "ProgressDialog").start();

                new Thread("ExportThread") {

                    @Override
                    public void run() {

                        try {
                            // change the peptide shaker icon to a "waiting version"
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                            progressDialog.setIndeterminate(false);

                            SequenceFactory sequenceFactory = SequenceFactory.getInstance();
                            progressDialog.setMax(sequenceFactory.getNTargetSequences());

                            FileWriter f = new FileWriter(finalOutputFile);
                            BufferedWriter b = new BufferedWriter(f);

                            ArrayList<String> accessions = sequenceFactory.getAccessions();
                            PSParameter probabilities = new PSParameter();

                            for (int i = 0; i < accessions.size(); i++) {
                                
                                Protein tempProtein = sequenceFactory.getProtein(accessions.get(i));
                             
                                if (!tempProtein.isDecoy()) {
                                    if(!peptideShakerGUI.getIdentification().matchExists(accessions.get(i))) {
                                        b.write(accessions.get(i) + "\n");
                                    } else if (includeNonValidatedCheckBox.isSelected()) {
                                        probabilities = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(accessions.get(i), probabilities);
                                        
                                        if (!probabilities.isValidated()) {
                                            b.write(accessions.get(i) + "\n");
                                        }  
                                    }
                                }
                                
                                progressDialog.incrementValue();
                            }

                            b.close();
                            f.close();

                            progressDialog.setVisible(false);
                            progressDialog.dispose();

                            // change the peptide shaker icon back to the default version
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                            JOptionPane.showMessageDialog(tempRef, "Undentified proteins exported to " + finalOutputFile + ".", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception e) {
                            // change the peptide shaker icon back to the default version
                            peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                            e.printStackTrace();
                            JOptionPane.showMessageDialog(tempRef, "An error occured when exporting the data.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                        }

                        if (progressDialog != null) {
                            progressDialog.setVisible(false);
                            progressDialog.dispose();
                        }
                    }
                }.start();
            }
        }
    }//GEN-LAST:event_exportUnidentifiedSpectraButtonActionPerformed

    /**
     * Indicates whether a spectrum is validated according to the user's settings.
     * @param spectrumKey   the key of the spectrum
     * @return a boolean indicating whether the spectrum is validated
     */
    private boolean isValidated(String spectrumKey) {
        PSParameter psParameter = new PSParameter();
        if (peptideShakerGUI.getIdentification().matchExists(spectrumKey)) {
            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);
        } else {
            return false;
        }
        switch (spectrumValidationCmb.getSelectedIndex()) {
            case 0:
                return psParameter.isValidated();
            case 1:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumMatch.getBestAssumption().getPeptide().getKey(), psParameter);
                    return psParameter.isValidated();
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            case 2:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    for (String protein : spectrumMatch.getBestAssumption().getPeptide().getParentProteins()) {
                        for (String proteinMatch : peptideShakerGUI.getIdentification().getProteinMap().get(protein)) {
                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinMatch, psParameter);
                            if (psParameter.isValidated()) {
                                return true;
                            }
                        }
                    }
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            default:
                return false;
        }
    }

    /**
     * Returns whether a peptide should be excluded from the inclusion list according to the GUI setting and the protein match it belongs to.
     * 
     * @param proteinMatch  the protein match this peptide belongs to
     * @param peptide       the peptide of interest
     * @return a boolean indicating whether this peptide should be excluded
     */
    private boolean shallExclude(String proteinKey, Peptide peptide) {
        if (miscleavedCheck.isSelected()
                && peptide.getNMissedCleavages(peptideShakerGUI.getSearchParameters().getEnzyme()) > 0) {
            return true;
        }
        if (reactiveCheck.isSelected()) {
            String sequence = peptide.getSequence();
            if (sequence.contains("M")
                    || sequence.contains("C")
                    || sequence.contains("W")
                    || sequence.contains("NG")
                    || sequence.contains("DG")
                    || sequence.contains("QG")
                    || sequence.startsWith("N")
                    || sequence.startsWith("Q")) {
                return true;
            }
        }
        if (isoformsCheck.isSelected() || isoformsUnrelatedCheck.isSelected() || unrelatedCheck.isSelected()) {
            PSParameter pSParameter = new PSParameter();
            pSParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, pSParameter);
            if (isoformsCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS) {
                return true;
            }
            if (isoformsUnrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS_UNRELATED) {
                return true;
            }
            if (unrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.UNRELATED) {
                return true;
            }
        }
        if (degeneratedCheck.isSelected()) {
            for (String protein : peptide.getParentProteins()) {
                if (!proteinKey.contains(protein)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Validates the user's input
     * @return a boolean indicating whether the input is valid.
     */
    private boolean validateInput() {
        try {
            double test = new Double(rtWindow.getText().trim());
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Please verify the input for the RT minimal window.", "Wrong input", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        return true;
    }

    /**
     * Returns a line to be output in an inclusion list according to the user's input
     * @param spectrumKey       The key of the spectrum
     * @param retentionTimes    The retention times found for this peptide
     * @return a line to be appended in the inclusion list
     * @throws Exception exception thrown whenever a problem was encountered while reading the spectrum file
     */
    private String getInclusionListLine(String spectrumKey, ArrayList<Double> retentionTimes) throws Exception {
        Collections.sort(retentionTimes);
        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
        double minWindow = new Double(rtWindow.getText().trim());
        switch (vendorCmb.getSelectedIndex()) {
            case 0:
                int index = (int) (0.25 * retentionTimes.size());
                double rtMin = retentionTimes.get(index) / 60;
                index = (int) (0.75 * retentionTimes.size());
                double rtMax = retentionTimes.get(index) / 60;
                if (rtMax - rtMin < minWindow / 60) {
                    index = (int) (0.5 * retentionTimes.size());
                    rtMin = (retentionTimes.get(index) - minWindow / 2) / 60;
                    rtMax = (retentionTimes.get(index) + minWindow / 2) / 60;
                }
                return precursor.getMz() + "\t" + rtMin + "\t" + rtMax + "\n";
            case 1:
                index = (int) (0.5 * retentionTimes.size());
                double rtInMin = retentionTimes.get(index) / 60;
                return rtInMin + "\t" + precursor.getMz() + "\n";
            case 2:
                index = (int) 0.5 * retentionTimes.size();
                double rt = retentionTimes.get(index);
                int index25 = (int) (0.25 * retentionTimes.size());
                int index75 = (int) (0.75 * retentionTimes.size());
                double range = retentionTimes.get(index75) - retentionTimes.get(index25);
                if (range < minWindow) {
                    range = minWindow;
                }
                if (peptideShakerGUI.getSearchParameters().getPrecursorAccuracyType() == SearchParameters.PrecursorAccuracyType.PPM) {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorAccuracy() / 1000000 * precursor.getMz();
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                } else { // Dalton
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorAccuracy() / spectrumMatch.getBestAssumption().getIdentificationCharge().value;
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                }
            case 3:
                index = (int) (0.5 * retentionTimes.size());
                rt = retentionTimes.get(index);
                return precursor.getMz() + "," + rt + "\n";
            default:
                return "";
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel backgroundPanel;
    private javax.swing.JCheckBox degeneratedCheck;
    private javax.swing.JButton exportMgfButton;
    private javax.swing.JButton exportProgenesisButton;
    private javax.swing.JButton exportUnidentifiedSpectraButton;
    private javax.swing.JComboBox idSelectionCmb;
    private javax.swing.JCheckBox includeNonValidatedCheckBox;
    private javax.swing.JButton inclusionListButton;
    private javax.swing.JPanel inclusionListPanel;
    private javax.swing.JCheckBox isoformsCheck;
    private javax.swing.JCheckBox isoformsUnrelatedCheck;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JCheckBox miscleavedCheck;
    private javax.swing.JPanel progenesisPanel;
    private javax.swing.JCheckBox reactiveCheck;
    private javax.swing.JTextField rtWindow;
    private javax.swing.JPanel spectraPanel;
    private javax.swing.JComboBox spectrumValidationCmb;
    private javax.swing.JButton srmButton;
    private javax.swing.JPanel unidentifiedProteinsPanel;
    private javax.swing.JCheckBox unrelatedCheck;
    private javax.swing.JComboBox vendorCmb;
    // End of variables declaration//GEN-END:variables
}
