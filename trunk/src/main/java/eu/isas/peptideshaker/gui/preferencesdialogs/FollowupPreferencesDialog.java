package eu.isas.peptideshaker.gui.preferencesdialogs;

import com.compomics.util.experiment.biology.Peptide;
import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.SequenceFactory;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.experiment.massspectrometry.Precursor;
import com.compomics.util.experiment.massspectrometry.Spectrum;
import com.compomics.util.experiment.massspectrometry.SpectrumFactory;
import com.compomics.util.gui.dialogs.ProgressDialogParent;
import com.compomics.util.gui.dialogs.ProgressDialogX;
import com.compomics.util.gui.renderers.AlignedListCellRenderer;
import eu.isas.peptideshaker.export.OutputGenerator;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import eu.isas.peptideshaker.preferences.SearchParameters;
import java.awt.Toolkit;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.filechooser.FileFilter;

/**
 * This class will allow the user to generate spectrum information for follow up
 * analysis
 *
 * @author Marc Vaudel
 * @author Harald Barsnes
 */
public class FollowupPreferencesDialog extends javax.swing.JDialog implements ProgressDialogParent {

    /**
     * The main GUI.
     */
    private PeptideShakerGUI peptideShakerGUI;
    /**
     * The spectrum factory.
     */
    private SpectrumFactory spectrumFactory = SpectrumFactory.getInstance();
    /**
     * A simple progress dialog.
     */
    private static ProgressDialogX progressDialog;
    /**
     * If true the progress bar is disposed of.
     */
    private static boolean cancelProgress = false;

    /**
     * Creates a new FollowupPreferencesDialog.
     *
     * @param peptideShakerGUI
     */
    public FollowupPreferencesDialog(PeptideShakerGUI peptideShakerGUI) {
        super(peptideShakerGUI, true);
        this.peptideShakerGUI = peptideShakerGUI;
        initComponents();

        spectrumRecalibrationCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        spectrumValidationCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        idSelectionCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        vendorCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));

        this.setLocationRelativeTo(peptideShakerGUI);
        setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        backgroundPanel = new javax.swing.JPanel();
        spectraPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        spectrumValidationCmb = new javax.swing.JComboBox();
        exportMgfButton = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        spectrumRecalibrationCmb = new javax.swing.JComboBox();
        recalibrateMgfButton = new javax.swing.JButton();
        inclusionListPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        miscleavedCheck = new javax.swing.JCheckBox();
        reactiveCheck = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        idSelectionCmb = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        vendorCmb = new javax.swing.JComboBox();
        inclusionListButton = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        isoformsCheck = new javax.swing.JCheckBox();
        isoformsUnrelatedCheck = new javax.swing.JCheckBox();
        unrelatedCheck = new javax.swing.JCheckBox();
        degeneratedCheck = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        rtWindow = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        progenesisPanel = new javax.swing.JPanel();
        exportProgenesisButton = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        unidentifiedProteinsPanel = new javax.swing.JPanel();
        jLabel10 = new javax.swing.JLabel();
        exportUnidentifiedSpectraAsFastaButton = new javax.swing.JButton();
        includeNonValidatedInUnidentifiedFastaCheckBox = new javax.swing.JCheckBox();
        jLabel11 = new javax.swing.JLabel();
        includeNonValidatedInProteinUnidentifiedCsvCheckBox = new javax.swing.JCheckBox();
        exportUnidentifiedSpectraAsCsvButton = new javax.swing.JButton();
        unidentifiedProteinsPanel1 = new javax.swing.JPanel();
        jLabel12 = new javax.swing.JLabel();
        exportIdentifiedSpectraAsFastaButton = new javax.swing.JButton();
        jLabel13 = new javax.swing.JLabel();
        exportIdentifiedSpectraAsCsvButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Export - Follow Up Analysis");
        setResizable(false);

        backgroundPanel.setBackground(new java.awt.Color(230, 230, 230));

        spectraPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Spectra"));
        spectraPanel.setOpaque(false);

        jLabel1.setText("Export Spectra from:");

        spectrumValidationCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Non-Validated PSMs", "Non-Validated Peptides", "Non-Validated Proteins" }));

        exportMgfButton.setText("Export as MGF");
        exportMgfButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportMgfButtonActionPerformed(evt);
            }
        });

        jLabel9.setText("Recalibrate spectra:");

        spectrumRecalibrationCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Precursor and Fragment Ions", "Precursor Ions", "Fragment Ions" }));

        recalibrateMgfButton.setText("Export as MGF");
        recalibrateMgfButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                recalibrateMgfButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout spectraPanelLayout = new javax.swing.GroupLayout(spectraPanel);
        spectraPanel.setLayout(spectraPanelLayout);
        spectraPanelLayout.setHorizontalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel9))
                .addGap(31, 31, 31)
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(spectraPanelLayout.createSequentialGroup()
                        .addComponent(spectrumValidationCmb, 0, 388, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(exportMgfButton, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(spectraPanelLayout.createSequentialGroup()
                        .addComponent(spectrumRecalibrationCmb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(recalibrateMgfButton, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        spectraPanelLayout.setVerticalGroup(
            spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, spectraPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel9)
                    .addComponent(recalibrateMgfButton)
                    .addComponent(spectrumRecalibrationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(spectraPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(exportMgfButton)
                    .addComponent(spectrumValidationCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        inclusionListPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Inclusion Lists"));
        inclusionListPanel.setOpaque(false);

        jLabel2.setText("Ignored Peptides:");

        miscleavedCheck.setSelected(true);
        miscleavedCheck.setText("miscleaved peptides");
        miscleavedCheck.setIconTextGap(10);
        miscleavedCheck.setOpaque(false);

        reactiveCheck.setSelected(true);
        reactiveCheck.setText("reactive peptides");
        reactiveCheck.setIconTextGap(10);
        reactiveCheck.setOpaque(false);

        jLabel3.setText("Include Validated PSMs:");

        idSelectionCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "All Validated PSMs", "Validated PSMs of All Validated Peptides", "Validated PSMs of Validated Peptides of All Validated Proteins", "Validated PSMs of Currently Displayed Peptides", "Validated PSMs of Currently Displayed Proteins" }));

        jLabel4.setText("Format:");

        vendorCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Thermo", "ABI", "Bruker", "MassLynx" }));

        inclusionListButton.setText("Generate Inclusion List");
        inclusionListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inclusionListButtonActionPerformed(evt);
            }
        });

        jLabel5.setText("Ignored Proteins:");

        isoformsCheck.setText("isoforms");
        isoformsCheck.setIconTextGap(10);
        isoformsCheck.setOpaque(false);

        isoformsUnrelatedCheck.setText("isoforms - unrelated proteins");
        isoformsUnrelatedCheck.setIconTextGap(10);
        isoformsUnrelatedCheck.setOpaque(false);

        unrelatedCheck.setSelected(true);
        unrelatedCheck.setText("unrelated proteins");
        unrelatedCheck.setIconTextGap(10);
        unrelatedCheck.setOpaque(false);

        degeneratedCheck.setSelected(true);
        degeneratedCheck.setText("degenerated peptides");
        degeneratedCheck.setIconTextGap(10);
        degeneratedCheck.setOpaque(false);

        jLabel6.setText("Minimum RT Window:");

        rtWindow.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        rtWindow.setText("20");

        jLabel7.setText("s");

        javax.swing.GroupLayout inclusionListPanelLayout = new javax.swing.GroupLayout(inclusionListPanel);
        inclusionListPanel.setLayout(inclusionListPanelLayout);
        inclusionListPanelLayout.setHorizontalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 142, Short.MAX_VALUE)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE))
                            .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(isoformsCheck, javax.swing.GroupLayout.PREFERRED_SIZE, 169, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(miscleavedCheck, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 169, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(reactiveCheck)
                                    .addComponent(isoformsUnrelatedCheck))
                                .addGap(24, 24, 24)
                                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(degeneratedCheck)
                                    .addComponent(unrelatedCheck)))
                            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                                .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel7))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(vendorCmb, 0, 378, Short.MAX_VALUE)
                            .addComponent(idSelectionCmb, 0, 378, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addComponent(inclusionListButton, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        inclusionListPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {degeneratedCheck, isoformsUnrelatedCheck, reactiveCheck, unrelatedCheck});

        inclusionListPanelLayout.setVerticalGroup(
            inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inclusionListPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(miscleavedCheck)
                            .addComponent(jLabel2)
                            .addComponent(reactiveCheck))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(isoformsCheck)
                            .addComponent(jLabel5)
                            .addComponent(unrelatedCheck)
                            .addComponent(isoformsUnrelatedCheck))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(rtWindow, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)))
                    .addComponent(degeneratedCheck))
                .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(idSelectionCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel3))
                    .addGroup(inclusionListPanelLayout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(inclusionListPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(vendorCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4)
                            .addComponent(inclusionListButton))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        progenesisPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Progenesis Export"));
        progenesisPanel.setOpaque(false);

        exportProgenesisButton.setText("Export CSV");
        exportProgenesisButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportProgenesisButtonActionPerformed(evt);
            }
        });

        jLabel8.setText("Export Spectrum IDs to Progenesis Tab Separated Phenyx Format:");

        javax.swing.GroupLayout progenesisPanelLayout = new javax.swing.GroupLayout(progenesisPanel);
        progenesisPanel.setLayout(progenesisPanelLayout);
        progenesisPanelLayout.setHorizontalGroup(
            progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(progenesisPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(exportProgenesisButton, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        progenesisPanelLayout.setVerticalGroup(
            progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(progenesisPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(progenesisPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel8)
                    .addComponent(exportProgenesisButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        unidentifiedProteinsPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Unidentified Proteins"));
        unidentifiedProteinsPanel.setOpaque(false);

        jLabel10.setText("<html>Export all the <b>unidentified</b> proteins as a FASTA file:</html>");

        exportUnidentifiedSpectraAsFastaButton.setText("Export as FASTA");
        exportUnidentifiedSpectraAsFastaButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportUnidentifiedSpectraAsFastaButtonActionPerformed(evt);
            }
        });

        includeNonValidatedInUnidentifiedFastaCheckBox.setSelected(true);
        includeNonValidatedInUnidentifiedFastaCheckBox.setText("Include Non-Validated");
        includeNonValidatedInUnidentifiedFastaCheckBox.setToolTipText("Include non-validated protein identification");
        includeNonValidatedInUnidentifiedFastaCheckBox.setIconTextGap(10);
        includeNonValidatedInUnidentifiedFastaCheckBox.setOpaque(false);

        jLabel11.setText("<html>Export all the <b>unidentified</b> proteins accession numbers:</html>");

        includeNonValidatedInProteinUnidentifiedCsvCheckBox.setSelected(true);
        includeNonValidatedInProteinUnidentifiedCsvCheckBox.setText("Include Non-Validated");
        includeNonValidatedInProteinUnidentifiedCsvCheckBox.setToolTipText("Include non-validated protein identification");
        includeNonValidatedInProteinUnidentifiedCsvCheckBox.setIconTextGap(10);
        includeNonValidatedInProteinUnidentifiedCsvCheckBox.setOpaque(false);

        exportUnidentifiedSpectraAsCsvButton.setText("Export as CSV");
        exportUnidentifiedSpectraAsCsvButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportUnidentifiedSpectraAsCsvButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout unidentifiedProteinsPanelLayout = new javax.swing.GroupLayout(unidentifiedProteinsPanel);
        unidentifiedProteinsPanel.setLayout(unidentifiedProteinsPanelLayout);
        unidentifiedProteinsPanelLayout.setHorizontalGroup(
            unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                        .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(includeNonValidatedInUnidentifiedFastaCheckBox))
                    .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                        .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(includeNonValidatedInProteinUnidentifiedCsvCheckBox)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 110, Short.MAX_VALUE)
                .addGroup(unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(exportUnidentifiedSpectraAsCsvButton, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE)
                    .addComponent(exportUnidentifiedSpectraAsFastaButton, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE))
                .addContainerGap())
        );
        unidentifiedProteinsPanelLayout.setVerticalGroup(
            unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(exportUnidentifiedSpectraAsFastaButton)
                    .addComponent(includeNonValidatedInUnidentifiedFastaCheckBox))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(unidentifiedProteinsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(exportUnidentifiedSpectraAsCsvButton)
                    .addComponent(includeNonValidatedInProteinUnidentifiedCsvCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        unidentifiedProteinsPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Identified Proteins"));
        unidentifiedProteinsPanel1.setOpaque(false);

        jLabel12.setText("<html>Export all the <b>identified</b> proteins as a FASTA file:</html>");

        exportIdentifiedSpectraAsFastaButton.setText("Export as FASTA");
        exportIdentifiedSpectraAsFastaButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportIdentifiedSpectraAsFastaButtonActionPerformed(evt);
            }
        });

        jLabel13.setText("<html>Export all the <b>identified</b> proteins accession numbers:</html>");

        exportIdentifiedSpectraAsCsvButton.setText("Export as CSV");
        exportIdentifiedSpectraAsCsvButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportIdentifiedSpectraAsCsvButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout unidentifiedProteinsPanel1Layout = new javax.swing.GroupLayout(unidentifiedProteinsPanel1);
        unidentifiedProteinsPanel1.setLayout(unidentifiedProteinsPanel1Layout);
        unidentifiedProteinsPanel1Layout.setHorizontalGroup(
            unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 279, Short.MAX_VALUE)
                .addGroup(unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(exportIdentifiedSpectraAsCsvButton, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE)
                    .addComponent(exportIdentifiedSpectraAsFastaButton, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE))
                .addContainerGap())
        );
        unidentifiedProteinsPanel1Layout.setVerticalGroup(
            unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(unidentifiedProteinsPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(exportIdentifiedSpectraAsFastaButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(unidentifiedProteinsPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(exportIdentifiedSpectraAsCsvButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout backgroundPanelLayout = new javax.swing.GroupLayout(backgroundPanel);
        backgroundPanel.setLayout(backgroundPanelLayout);
        backgroundPanelLayout.setHorizontalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(spectraPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(unidentifiedProteinsPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(unidentifiedProteinsPanel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(progenesisPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(inclusionListPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        backgroundPanelLayout.setVerticalGroup(
            backgroundPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(spectraPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(unidentifiedProteinsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(unidentifiedProteinsPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(11, 11, 11)
                .addComponent(progenesisPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(inclusionListPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Export the given spectra as an mgf file.
     *
     * @param evt
     */
    private void exportMgfButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportMgfButtonActionPerformed

        final File finalOutputFile = peptideShakerGUI.getUserSelectedFile(".mgf", "(Mascot Generic File) *.mgf", "Select Destination File", false);

        if (finalOutputFile != null) {

            progressDialog = new ProgressDialogX(this, this, true);

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    progressDialog.setVisible(true);
                }
            }, "ProgressDialog").start();

            new Thread("SaveThread") {

                @Override
                public void run() {

                    try {
                        // change the peptide shaker icon to a "waiting version"
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                        progressDialog.setIndeterminate(false);
                        int total = 0;
                        for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                            total += spectrumFactory.getSpectrumTitles(mgfFile).size();
                        }
                        progressDialog.setMax(total);

                        FileWriter f = new FileWriter(finalOutputFile);
                        BufferedWriter b = new BufferedWriter(f);

                        for (String mgfFile : spectrumFactory.getMgfFileNames()) {
                            for (String spectrumTitle : spectrumFactory.getSpectrumTitles(mgfFile)) {
                                String spectrumKey = Spectrum.getSpectrumKey(mgfFile, spectrumTitle);
                                if (!isValidated(spectrumKey)) {
                                    b.write(((MSnSpectrum) spectrumFactory.getSpectrum(spectrumKey)).asMgf());
                                }
                                progressDialog.incrementValue();

                                if (cancelProgress) {
                                    break;
                                }
                            }

                            if (cancelProgress) {
                                break;
                            }
                        }

                        b.close();
                        f.close();

                        progressDialog.dispose();

                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Spectra saved to " + finalOutputFile + ".", "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } catch (Exception e) {
                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                        e.printStackTrace();
                        JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }

                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportMgfButtonActionPerformed

    /**
     * Export the inclusion list to file.
     *
     * @param evt
     */
    private void inclusionListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inclusionListButtonActionPerformed


        if (validateInput()) {
            final JFileChooser fileChooser = new JFileChooser(peptideShakerGUI.getLastSelectedFolder());
            fileChooser.setDialogTitle("Select Destination File");
            fileChooser.setMultiSelectionEnabled(false);

            FileFilter filter = new FileFilter() {

                @Override
                public boolean accept(File myFile) {
                    if (vendorCmb.getSelectedIndex() == 2) {
                        return myFile.isDirectory() || myFile.getName().endsWith(".csv");
                    }
                    return myFile.isDirectory() || myFile.getName().endsWith(".txt");
                }

                @Override
                public String getDescription() {
                    switch (vendorCmb.getSelectedIndex()) {
                        case 0:
                            return "(Thermo inclusion list) .txt";
                        case 1:
                            return "(ABI inclusion list) .txt";
                        case 2:
                            return "(Bruker inclusion list) .csv";
                        case 3:
                            return "(MassLynx inclusion list) .txt";
                        default:
                            return "(unknown format) .txt";
                    }
                }
            };

            fileChooser.setFileFilter(filter);

            int returnVal = fileChooser.showSaveDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {

                File tempOutputFile = fileChooser.getSelectedFile();

                int outcome = JOptionPane.YES_OPTION;

                if (tempOutputFile.exists()) {
                    outcome = JOptionPane.showConfirmDialog(this,
                            "Should " + tempOutputFile + " be overwritten?", "Selected File Already Exists",
                            JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                }

                if (outcome == JOptionPane.YES_OPTION) {

                    if (vendorCmb.getSelectedIndex() == 2) {
                        if (!tempOutputFile.getName().endsWith(".csv")) {
                            tempOutputFile = new File(tempOutputFile.getParent(), tempOutputFile.getName() + ".csv");
                        }
                    } else {
                        if (!tempOutputFile.getName().endsWith(".txt")) {
                            tempOutputFile = new File(tempOutputFile.getParent(), tempOutputFile.getName() + ".txt");
                        }
                    }

                    progressDialog = new ProgressDialogX(this, this, true);

                    // needed due to threading issues
                    final File outputFile = tempOutputFile;
                    final FollowupPreferencesDialog tempRef = this;

                    new Thread(new Runnable() {

                        public void run() {
                            progressDialog.setIndeterminate(true);
                            progressDialog.setTitle("Exporting. Please Wait...");
                            progressDialog.setVisible(true);
                        }
                    }, "ProgressDialog").start();

                    new Thread("SaveThread") {

                        @Override
                        public void run() {

                            try {

                                // change the peptide shaker icon to a "waiting version"
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                                ArrayList<String> inspectedProteins;

                                if (idSelectionCmb.getSelectedIndex() == 4) {
                                    inspectedProteins = peptideShakerGUI.getDisplayedProteins();
                                } else {
                                    inspectedProteins = new ArrayList<String>(peptideShakerGUI.getIdentification().getProteinIdentification());
                                }

                                progressDialog.setIndeterminate(false);
                                progressDialog.setMax(inspectedProteins.size());
                                ArrayList<String> displayedPeptides = peptideShakerGUI.getDisplayedPeptides();
                                FileWriter f = new FileWriter(outputFile);
                                BufferedWriter b = new BufferedWriter(f);
                                PSParameter psParameter = new PSParameter();
                                int cpt = 0;

                                for (String proteinKey : inspectedProteins) {

                                    ProteinMatch proteinMatch = peptideShakerGUI.getIdentification().getProteinMatch(proteinKey);
                                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, psParameter);

                                    if (idSelectionCmb.getSelectedIndex() == 0
                                            || idSelectionCmb.getSelectedIndex() == 1
                                            || idSelectionCmb.getSelectedIndex() == 3
                                            || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()) {

                                        for (String peptideKey : proteinMatch.getPeptideMatches()) {

                                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(peptideKey, psParameter);

                                            if (idSelectionCmb.getSelectedIndex() == 0
                                                    || idSelectionCmb.getSelectedIndex() == 1 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 2 && psParameter.isValidated()
                                                    || idSelectionCmb.getSelectedIndex() == 3 && displayedPeptides.contains(peptideKey)) {

                                                PeptideMatch peptideMatch = peptideShakerGUI.getIdentification().getPeptideMatch(peptideKey);

                                                if (!shallExclude(proteinKey, peptideMatch.getTheoreticPeptide())) {

                                                    ArrayList<Double> retentionTimes = new ArrayList<Double>();

                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {
                                                        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
                                                        retentionTimes.add(precursor.getRt());
                                                    }

                                                    for (String spectrumKey : peptideMatch.getSpectrumMatches()) {

                                                        psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);

                                                        if (psParameter.isValidated()) {
                                                            b.write(getInclusionListLine(spectrumKey, retentionTimes));
                                                        }
                                                    }
                                                }
                                            }

                                            if (cancelProgress) {
                                                break;
                                            }
                                        }
                                    }

                                    cpt++;
                                    progressDialog.setValue(cpt);

                                    if (cancelProgress) {
                                        break;
                                    }
                                }

                                b.close();
                                f.close();

                                progressDialog.dispose();

                                // change the peptide shaker icon back to the default version
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                                if (!cancelProgress) {
                                    JOptionPane.showMessageDialog(tempRef, "Inclusion list saved to " + fileChooser.getSelectedFile().getName() + ".",
                                            "Save Complete", JOptionPane.INFORMATION_MESSAGE);
                                }
                            } catch (Exception e) {
                                // change the peptide shaker icon back to the default version
                                peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                                e.printStackTrace();
                                JOptionPane.showMessageDialog(tempRef, "An error occured when saving the file.", "Saving Failed", JOptionPane.ERROR_MESSAGE);
                            }

                            if (progressDialog != null) {
                                progressDialog.dispose();
                            }

                            cancelProgress = false;
                        }
                    }.start();
                }
            }
        }
    }//GEN-LAST:event_inclusionListButtonActionPerformed

    /**
     * Export the Spectrum IDs as a Phenyx tab separated text file for input to
     * Progenesis. Only works if the mgf files came from Progenesis in the first
     * place.
     *
     * @param evt
     */
    private void exportProgenesisButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportProgenesisButtonActionPerformed

        final File finalOutputFile = peptideShakerGUI.getUserSelectedFile(".txt", "(Tab Separated Text File) *.txt", "Select Destination File", false);

        if (finalOutputFile != null) {

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            progressDialog = new ProgressDialogX(this, this, true);

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    try {
                        progressDialog.setVisible(true);
                    } catch (IndexOutOfBoundsException e) {
                        // ignore
                    }
                }
            }, "ProgressDialog").start();

            new Thread("ExoportThread") {

                @Override
                public void run() {

                    try {
                        progressDialog.setIndeterminate(true);
                        progressDialog.setTitle("Exporting. Please Wait...");

                        FileWriter f = new FileWriter(finalOutputFile);
                        BufferedWriter b = new BufferedWriter(f);

                        OutputGenerator outputGenerator = new OutputGenerator(peptideShakerGUI);
                        outputGenerator.getPSMsProgenesisExport(progressDialog, cancelProgress, null, b);

                        b.close();
                        f.close();

                        progressDialog.dispose();

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Results exported to \'" + finalOutputFile.getName() + "\'.", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        }

                    } catch (IOException e) {
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                        e.printStackTrace();
                    } catch (Exception e) {
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                        e.printStackTrace();
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }

                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportProgenesisButtonActionPerformed

    /**
     * Export all the unidentified proteins to a FASTA file.
     *
     * @param evt
     */
    private void exportUnidentifiedSpectraAsFastaButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportUnidentifiedSpectraAsFastaButtonActionPerformed

        // get the file to send the output to
        final File selectedFile = peptideShakerGUI.getUserSelectedFile(".fasta", "Supported formats: FASTA format (.fasta)", "Select Destination File", false);

        if (selectedFile != null) {

            progressDialog = new ProgressDialogX(this, this, true);

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    try {
                        progressDialog.setVisible(true);
                    } catch (IndexOutOfBoundsException e) {
                        // ignore
                    }
                }
            }, "ProgressDialog").start();

            new Thread("ExportThread") {

                @Override
                public void run() {

                    try {
                        // change the peptide shaker icon to a "waiting version"
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                        progressDialog.setIndeterminate(false);

                        SequenceFactory sequenceFactory = SequenceFactory.getInstance();
                        progressDialog.setMax(sequenceFactory.getNTargetSequences());

                        FileWriter f = new FileWriter(selectedFile);
                        BufferedWriter b = new BufferedWriter(f);

                        ArrayList<String> accessions = sequenceFactory.getAccessions();
                        PSParameter probabilities = new PSParameter();

                        for (int i = 0; i < accessions.size(); i++) {

                            Protein tempProtein = sequenceFactory.getProtein(accessions.get(i));

                            if (!tempProtein.isDecoy()) {
                                if (!peptideShakerGUI.getIdentification().matchExists(accessions.get(i))) {
                                    b.write(sequenceFactory.getHeader(accessions.get(i)).toString() + "\n");
                                    b.write(sequenceFactory.getProtein(accessions.get(i)).getSequence() + "\n");
                                } else if (includeNonValidatedInUnidentifiedFastaCheckBox.isSelected()) {
                                    probabilities = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(accessions.get(i), probabilities);

                                    if (!probabilities.isValidated()) {
                                        b.write(sequenceFactory.getHeader(accessions.get(i)).toString() + "\n");
                                        b.write(sequenceFactory.getProtein(accessions.get(i)).getSequence() + "\n");
                                    }
                                }
                            }

                            progressDialog.incrementValue();

                            if (cancelProgress) {
                                break;
                            }
                        }

                        b.close();
                        f.close();

                        progressDialog.dispose();

                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Unidentified proteins exported to " + selectedFile.getPath() + ".", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } catch (Exception e) {
                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                        e.printStackTrace();
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting the data.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }

                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportUnidentifiedSpectraAsFastaButtonActionPerformed

    /**
     * Export all the unidentified protein accession numbers to a tab separated
     * text file.
     *
     * @param evt
     */
    private void exportUnidentifiedSpectraAsCsvButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportUnidentifiedSpectraAsCsvButtonActionPerformed

        // get the file to send the output to
        final File selectedFile = peptideShakerGUI.getUserSelectedFile(".txt", "(Tab Separated Text File) *.txt", "Select Destination File", false);

        if (selectedFile != null) {

            progressDialog = new ProgressDialogX(this, this, true);

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    try {
                        progressDialog.setVisible(true);
                    } catch (IndexOutOfBoundsException e) {
                        // ignore
                    }
                }
            }, "ProgressDialog").start();

            new Thread("ExportThread") {

                @Override
                public void run() {

                    try {
                        // change the peptide shaker icon to a "waiting version"
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                        progressDialog.setIndeterminate(false);

                        SequenceFactory sequenceFactory = SequenceFactory.getInstance();
                        progressDialog.setMax(sequenceFactory.getNTargetSequences());

                        FileWriter f = new FileWriter(selectedFile);
                        BufferedWriter b = new BufferedWriter(f);

                        ArrayList<String> accessions = sequenceFactory.getAccessions();
                        PSParameter probabilities = new PSParameter();

                        for (int i = 0; i < accessions.size(); i++) {

                            Protein tempProtein = sequenceFactory.getProtein(accessions.get(i));

                            if (!tempProtein.isDecoy()) {
                                if (!peptideShakerGUI.getIdentification().matchExists(accessions.get(i))) {
                                    b.write(accessions.get(i) + "\n");
                                } else if (includeNonValidatedInProteinUnidentifiedCsvCheckBox.isSelected()) {
                                    probabilities = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(accessions.get(i), probabilities);

                                    if (!probabilities.isValidated()) {
                                        b.write(accessions.get(i) + "\n");
                                    }
                                }
                            }

                            progressDialog.incrementValue();

                            if (cancelProgress) {
                                break;
                            }
                        }

                        b.close();
                        f.close();

                        progressDialog.dispose();

                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Unidentified proteins exported to " + selectedFile.getPath() + ".", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } catch (Exception e) {
                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                        e.printStackTrace();
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting the data.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }

                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportUnidentifiedSpectraAsCsvButtonActionPerformed

    /**
     * Export all the identified proteins to a FASTA file.
     *
     * @param evt
     */
    private void exportIdentifiedSpectraAsFastaButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportIdentifiedSpectraAsFastaButtonActionPerformed

        // get the file to send the output to
        final File selectedFile = peptideShakerGUI.getUserSelectedFile(".fasta", "Supported formats: FASTA format (.fasta)", "Select Destination File", false);

        if (selectedFile != null) {

            progressDialog = new ProgressDialogX(this, this, true);

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    try {
                        progressDialog.setVisible(true);
                    } catch (IndexOutOfBoundsException e) {
                        // ignore
                    }
                }
            }, "ProgressDialog").start();

            new Thread("ExportThread") {

                @Override
                public void run() {

                    try {
                        // change the peptide shaker icon to a "waiting version"
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                        progressDialog.setIndeterminate(false);

                        SequenceFactory sequenceFactory = SequenceFactory.getInstance();
                        progressDialog.setMax(sequenceFactory.getNTargetSequences());

                        FileWriter f = new FileWriter(selectedFile);
                        BufferedWriter b = new BufferedWriter(f);

                        ArrayList<String> accessions = sequenceFactory.getAccessions();
                        PSParameter probabilities = new PSParameter();

                        for (int i = 0; i < accessions.size(); i++) {

                            Protein tempProtein = sequenceFactory.getProtein(accessions.get(i));

                            if (!tempProtein.isDecoy()) {
                                if (peptideShakerGUI.getIdentification().matchExists(accessions.get(i))) {

                                    probabilities = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(accessions.get(i), probabilities);

                                    if (probabilities.isValidated()) {
                                        b.write(sequenceFactory.getHeader(accessions.get(i)).toString() + "\n");
                                        b.write(sequenceFactory.getProtein(accessions.get(i)).getSequence() + "\n");
                                    }
                                }
                            }

                            progressDialog.incrementValue();

                            if (cancelProgress) {
                                break;
                            }
                        }

                        b.close();
                        f.close();


                        progressDialog.dispose();

                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Identified proteins exported to " + selectedFile.getPath() + ".", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } catch (Exception e) {
                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                        e.printStackTrace();
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting the data.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }

                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportIdentifiedSpectraAsFastaButtonActionPerformed

    /**
     * Export all the identified protein accession numbers to a tab separated
     * text file.
     *
     * @param evt
     */
    private void exportIdentifiedSpectraAsCsvButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportIdentifiedSpectraAsCsvButtonActionPerformed

        // get the file to send the output to
        final File selectedFile = peptideShakerGUI.getUserSelectedFile(".txt", "(Tab Separated Text File) *.txt", "Select Destination File", false);

        if (selectedFile != null) {

            progressDialog = new ProgressDialogX(this, this, true);

            final FollowupPreferencesDialog tempRef = this; // needed due to threading issues

            new Thread(new Runnable() {

                public void run() {
                    progressDialog.setIndeterminate(true);
                    progressDialog.setTitle("Exporting. Please Wait...");
                    try {
                        progressDialog.setVisible(true);
                    } catch (IndexOutOfBoundsException e) {
                        // ignore
                    }
                }
            }, "ProgressDialog").start();

            new Thread("ExportThread") {

                @Override
                public void run() {

                    try {
                        // change the peptide shaker icon to a "waiting version"
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker-orange.gif")));

                        progressDialog.setIndeterminate(false);

                        SequenceFactory sequenceFactory = SequenceFactory.getInstance();
                        progressDialog.setMax(sequenceFactory.getNTargetSequences());

                        FileWriter f = new FileWriter(selectedFile);
                        BufferedWriter b = new BufferedWriter(f);

                        ArrayList<String> accessions = sequenceFactory.getAccessions();
                        PSParameter probabilities = new PSParameter();

                        for (int i = 0; i < accessions.size(); i++) {

                            Protein tempProtein = sequenceFactory.getProtein(accessions.get(i));

                            if (!tempProtein.isDecoy()) {
                                if (peptideShakerGUI.getIdentification().matchExists(accessions.get(i))) {

                                    probabilities = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(accessions.get(i), probabilities);

                                    if (probabilities.isValidated()) {
                                        b.write(accessions.get(i) + "\n");
                                    }
                                }
                            }

                            progressDialog.incrementValue();

                            if (cancelProgress) {
                                break;
                            }
                        }

                        b.close();
                        f.close();


                        progressDialog.dispose();

                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));

                        if (!cancelProgress) {
                            JOptionPane.showMessageDialog(tempRef, "Identified proteins exported to " + selectedFile.getPath() + ".", "Export Complete", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } catch (Exception e) {
                        // change the peptide shaker icon back to the default version
                        peptideShakerGUI.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/icons/peptide-shaker.gif")));
                        e.printStackTrace();
                        JOptionPane.showMessageDialog(tempRef, "An error occured when exporting the data.", "Export Failed", JOptionPane.ERROR_MESSAGE);
                    }

                    if (progressDialog != null) {
                        progressDialog.dispose();
                    }
                    
                    cancelProgress = false;
                }
            }.start();
        }
    }//GEN-LAST:event_exportIdentifiedSpectraAsCsvButtonActionPerformed

    private void recalibrateMgfButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_recalibrateMgfButtonActionPerformed
       boolean ms1 = true;
       boolean ms2 = true;
       if (spectrumRecalibrationCmb.getSelectedIndex() == 1) {
           ms2 = false;
       } else if (spectrumRecalibrationCmb.getSelectedIndex() == 2) {
           ms1 = false;
       }
       peptideShakerGUI.recalibrateSpectra(ms1, ms2);
    }//GEN-LAST:event_recalibrateMgfButtonActionPerformed

    /**
     * Indicates whether a spectrum is validated according to the user's
     * settings.
     *
     * @param spectrumKey the key of the spectrum
     * @return a boolean indicating whether the spectrum is validated
     */
    private boolean isValidated(String spectrumKey) {
        PSParameter psParameter = new PSParameter();
        if (peptideShakerGUI.getIdentification().matchExists(spectrumKey)) {
            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumKey, psParameter);
        } else {
            return false;
        }
        switch (spectrumValidationCmb.getSelectedIndex()) {
            case 0:
                return psParameter.isValidated();
            case 1:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(spectrumMatch.getBestAssumption().getPeptide().getKey(), psParameter);
                    return psParameter.isValidated();
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            case 2:
                if (!psParameter.isValidated()) {
                    return false;
                }
                try {
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    for (String protein : spectrumMatch.getBestAssumption().getPeptide().getParentProteins()) {
                        for (String proteinMatch : peptideShakerGUI.getIdentification().getProteinMap().get(protein)) {
                            psParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinMatch, psParameter);
                            if (psParameter != null && psParameter.isValidated()) {
                                return true;
                            }
                        }
                    }
                } catch (Exception e) {
                    peptideShakerGUI.catchException(e);
                }
                return false;
            default:
                return false;
        }
    }

    /**
     * Returns whether a peptide should be excluded from the inclusion list
     * according to the GUI setting and the protein match it belongs to.
     *
     * @param proteinMatch the protein match this peptide belongs to
     * @param peptide the peptide of interest
     * @return a boolean indicating whether this peptide should be excluded
     */
    private boolean shallExclude(String proteinKey, Peptide peptide) {
        if (miscleavedCheck.isSelected()
                && peptide.getNMissedCleavages(peptideShakerGUI.getSearchParameters().getEnzyme()) > 0) {
            return true;
        }
        if (reactiveCheck.isSelected()) {
            String sequence = peptide.getSequence();
            if (sequence.contains("M")
                    || sequence.contains("C")
                    || sequence.contains("W")
                    || sequence.contains("NG")
                    || sequence.contains("DG")
                    || sequence.contains("QG")
                    || sequence.startsWith("N")
                    || sequence.startsWith("Q")) {
                return true;
            }
        }
        if (isoformsCheck.isSelected() || isoformsUnrelatedCheck.isSelected() || unrelatedCheck.isSelected()) {
            PSParameter pSParameter = new PSParameter();
            pSParameter = (PSParameter) peptideShakerGUI.getIdentification().getMatchParameter(proteinKey, pSParameter);
            if (isoformsCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS) {
                return true;
            }
            if (isoformsUnrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.ISOFORMS_UNRELATED) {
                return true;
            }
            if (unrelatedCheck.isSelected() && pSParameter.getGroupClass() == PSParameter.UNRELATED) {
                return true;
            }
        }
        if (degeneratedCheck.isSelected()) {
            for (String protein : peptide.getParentProteins()) {
                if (!proteinKey.contains(protein)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Validates the user's input.
     *
     * @return a boolean indicating whether the input is valid.
     */
    private boolean validateInput() {
        try {
            new Double(rtWindow.getText().trim());
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Please verify the input for the RT minimal window.", "Wrong input", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        return true;
    }

    /**
     * Returns a line to be output in an inclusion list according to the user's
     * input.
     *
     * @param spectrumKey The key of the spectrum
     * @param retentionTimes The retention times found for this peptide
     * @return a line to be appended in the inclusion list
     * @throws Exception exception thrown whenever a problem was encountered
     * while reading the spectrum file
     */
    private String getInclusionListLine(String spectrumKey, ArrayList<Double> retentionTimes) throws Exception {
        Collections.sort(retentionTimes);
        Precursor precursor = spectrumFactory.getPrecursor(spectrumKey);
        double minWindow = new Double(rtWindow.getText().trim());
        switch (vendorCmb.getSelectedIndex()) {
            case 0:
                int index = (int) (0.25 * retentionTimes.size());
                double rtMin = retentionTimes.get(index) / 60;
                index = (int) (0.75 * retentionTimes.size());
                double rtMax = retentionTimes.get(index) / 60;
                if (rtMax - rtMin < minWindow / 60) {
                    index = (int) (0.5 * retentionTimes.size());
                    rtMin = (retentionTimes.get(index) - minWindow / 2) / 60;
                    rtMax = (retentionTimes.get(index) + minWindow / 2) / 60;
                }
                return precursor.getMz() + "\t" + rtMin + "\t" + rtMax + "\n";
            case 1:
                index = (int) (0.5 * retentionTimes.size());
                double rtInMin = retentionTimes.get(index) / 60;
                return rtInMin + "\t" + precursor.getMz() + "\n";
            case 2:
                index = (int) 0.5 * retentionTimes.size();
                double rt = retentionTimes.get(index);
                int index25 = (int) (0.25 * retentionTimes.size());
                int index75 = (int) (0.75 * retentionTimes.size());
                double range = retentionTimes.get(index75) - retentionTimes.get(index25);
                if (range < minWindow) {
                    range = minWindow;
                }
                if (peptideShakerGUI.getSearchParameters().getPrecursorAccuracyType() == SearchParameters.PrecursorAccuracyType.PPM) {
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorAccuracy() / 1000000 * precursor.getMz();
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                } else { // Dalton
                    SpectrumMatch spectrumMatch = peptideShakerGUI.getIdentification().getSpectrumMatch(spectrumKey);
                    double deltaMZ = peptideShakerGUI.getSearchParameters().getPrecursorAccuracy() / spectrumMatch.getBestAssumption().getIdentificationCharge().value;
                    double mzMin = precursor.getMz() - deltaMZ;
                    double mzMax = precursor.getMz() + deltaMZ;
                    return rt + "," + range + "," + mzMin + "," + mzMax + "\n";
                }
            case 3:
                index = (int) (0.5 * retentionTimes.size());
                rt = retentionTimes.get(index);
                return precursor.getMz() + "," + rt + "\n";
            default:
                return "";
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel backgroundPanel;
    private javax.swing.JCheckBox degeneratedCheck;
    private javax.swing.JButton exportIdentifiedSpectraAsCsvButton;
    private javax.swing.JButton exportIdentifiedSpectraAsFastaButton;
    private javax.swing.JButton exportMgfButton;
    private javax.swing.JButton exportProgenesisButton;
    private javax.swing.JButton exportUnidentifiedSpectraAsCsvButton;
    private javax.swing.JButton exportUnidentifiedSpectraAsFastaButton;
    private javax.swing.JComboBox idSelectionCmb;
    private javax.swing.JCheckBox includeNonValidatedInProteinUnidentifiedCsvCheckBox;
    private javax.swing.JCheckBox includeNonValidatedInUnidentifiedFastaCheckBox;
    private javax.swing.JButton inclusionListButton;
    private javax.swing.JPanel inclusionListPanel;
    private javax.swing.JCheckBox isoformsCheck;
    private javax.swing.JCheckBox isoformsUnrelatedCheck;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JCheckBox miscleavedCheck;
    private javax.swing.JPanel progenesisPanel;
    private javax.swing.JCheckBox reactiveCheck;
    private javax.swing.JButton recalibrateMgfButton;
    private javax.swing.JTextField rtWindow;
    private javax.swing.JPanel spectraPanel;
    private javax.swing.JComboBox spectrumRecalibrationCmb;
    private javax.swing.JComboBox spectrumValidationCmb;
    private javax.swing.JPanel unidentifiedProteinsPanel;
    private javax.swing.JPanel unidentifiedProteinsPanel1;
    private javax.swing.JCheckBox unrelatedCheck;
    private javax.swing.JComboBox vendorCmb;
    // End of variables declaration//GEN-END:variables

    @Override
    public void cancelProgress() {
        cancelProgress = true;
    }
}
