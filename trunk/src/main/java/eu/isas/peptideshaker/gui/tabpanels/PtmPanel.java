/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PtmPanel.java
 *
 * Created on Apr 15, 2011, 9:30:21 AM
 */
package eu.isas.peptideshaker.gui.tabpanels;

import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.Identification;
import com.compomics.util.experiment.identification.matches.ModificationMatch;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author vaudel
 */
public class PtmPanel extends javax.swing.JPanel {

    /** Creates new form PtmPanel */
    public PtmPanel(PeptideShakerGUI parent) {
        this.parent = parent;
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        modificationsList = new javax.swing.JList();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        peptidesTable = new javax.swing.JTable();
        jSplitPane1 = new javax.swing.JSplitPane();
        jSplitPane2 = new javax.swing.JSplitPane();
        jSplitPane3 = new javax.swing.JSplitPane();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane4 = new javax.swing.JScrollPane();
        psmsTable = new javax.swing.JTable();
        jPanel4 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        relatedPeptidesTable = new javax.swing.JTable();
        jPanel5 = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Variable Modifications"));

        modificationsList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                modificationsListMouseClicked(evt);
            }
        });
        jScrollPane1.setViewportView(modificationsList);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 218, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 296, Short.MAX_VALUE)
                .addContainerGap())
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Peptides"));

        peptidesTable.setModel(new PeptideTable()
        );
        peptidesTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        peptidesTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                peptidesTableMouseClicked(evt);
            }
        });
        jScrollPane2.setViewportView(peptidesTable);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 782, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 296, Short.MAX_VALUE)
                .addContainerGap())
        );

        jSplitPane1.setDividerLocation(400);
        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        jSplitPane2.setDividerLocation(600);

        jSplitPane3.setDividerLocation(200);
        jSplitPane3.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder("PSMs"));

        psmsTable.setModel(new PsmsTable());
        psmsTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane4.setViewportView(psmsTable);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 561, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 139, Short.MAX_VALUE)
                .addContainerGap())
        );

        jSplitPane3.setBottomComponent(jPanel3);

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("Related Peptides"));

        relatedPeptidesTable.setModel(new RelatedPeptidesTable());
        relatedPeptidesTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        relatedPeptidesTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                relatedPeptidesTableMouseClicked(evt);
            }
        });
        jScrollPane3.setViewportView(relatedPeptidesTable);

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 561, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 147, Short.MAX_VALUE)
                .addContainerGap())
        );

        jSplitPane3.setLeftComponent(jPanel4);

        jSplitPane2.setLeftComponent(jSplitPane3);

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder("Spectrum"));

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 454, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 367, Short.MAX_VALUE)
        );

        jSplitPane2.setRightComponent(jPanel5);

        jSplitPane1.setTopComponent(jSplitPane2);

        jPanel6.setBorder(javax.swing.BorderFactory.createTitledBorder("PTM location"));

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1060, Short.MAX_VALUE)
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 134, Short.MAX_VALUE)
        );

        jSplitPane1.setRightComponent(jPanel6);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 570, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void modificationsListMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_modificationsListMouseClicked
        updatePeptideTable();
    }//GEN-LAST:event_modificationsListMouseClicked

    private void peptidesTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_peptidesTableMouseClicked
        if (relatedPeptidesTable.getSelectedRowCount() > 0) {
            int selectedRow = relatedPeptidesTable.getSelectedRow();
            relatedPeptidesTable.getSelectionModel().removeSelectionInterval(selectedRow, selectedRow);
        }
        updateRelatedPeptidesTable();
        updatePsmTable();
    }//GEN-LAST:event_peptidesTableMouseClicked

    private void relatedPeptidesTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_relatedPeptidesTableMouseClicked
        if (peptidesTable.getSelectedRowCount() > 0) {
            int selectedRow = peptidesTable.getSelectedRow();
            peptidesTable.getSelectionModel().removeSelectionInterval(selectedRow, selectedRow);
        }
        updatePsmTable();
    }//GEN-LAST:event_relatedPeptidesTableMouseClicked
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JSplitPane jSplitPane2;
    private javax.swing.JSplitPane jSplitPane3;
    private javax.swing.JList modificationsList;
    private javax.swing.JTable peptidesTable;
    private javax.swing.JTable psmsTable;
    private javax.swing.JTable relatedPeptidesTable;
    // End of variables declaration//GEN-END:variables
    /**
     * The peptide shaker gui
     */
    private PeptideShakerGUI parent;
    /**
     * Map of all peptide keys indexed by their modification status
     */
    private HashMap<String, ArrayList<String>> peptideMap = new HashMap<String, ArrayList<String>>();
    /**
     * The modification name for no modification
     */
    private final String NO_MODIFICATION = "No modification";
    /**
     * The displayed identification
     */
    private Identification identification;
    /**
     * The keys of the peptides currently displayed
     */
    private ArrayList<String> displayedPeptides = new ArrayList<String>();
    /**
     * The keys of the related peptides currently displayed
     */
    private ArrayList<String> relatedPeptides = new ArrayList<String>();
    /**
     * The keys of the PSMs currently displayed
     */
    private ArrayList<String> displayedPsms = new ArrayList<String>();

    /**
     * Creates the peptide map
     */
    private void createPeptideMap() {
        String modificationName;
        boolean modified;
        ArrayList<String> accountedModifications;
        for (PeptideMatch peptideMatch : identification.getPeptideIdentification().values()) {
            modified = false;
            accountedModifications = new ArrayList<String>();
            for (ModificationMatch modificationMatch : peptideMatch.getTheoreticPeptide().getModificationMatches()) {
                if (modificationMatch.isVariable()) {
                    modificationName = modificationMatch.getTheoreticPtm().getName();
                    if (!accountedModifications.contains(modificationName)) {
                        if (!peptideMap.containsKey(modificationName)) {
                            peptideMap.put(modificationName, new ArrayList<String>());
                        }
                        peptideMap.get(modificationName).add(peptideMatch.getKey());
                        modified = true;
                        accountedModifications.add(modificationName);
                    }
                }
            }
            if (!modified) {
                if (!peptideMap.containsKey(NO_MODIFICATION)) {
                    peptideMap.put(NO_MODIFICATION, new ArrayList<String>());
                }
                peptideMap.get(NO_MODIFICATION).add(peptideMatch.getKey());
            }
        }
    }

    /**
     * Displays the results
     */
    public void displayResults() {
        this.identification = parent.getIdentification();
        createPeptideMap();
        String[] modifications = new String[peptideMap.size()];
        int cpt = 0;
        for (String modification : peptideMap.keySet()) {
            modifications[cpt] = modification;
            cpt++;
        }
        Arrays.sort(modifications);
        modificationsList.setListData(modifications);
        modificationsList.setSelectedIndex(0);
        updatePeptideTable();
    }

    private void updatePeptideTable() {
        HashMap<Double, ArrayList<String>> scoreToPeptideMap = new HashMap<Double, ArrayList<String>>();
        PeptideMatch peptideMatch;
        PSParameter probabilities = new PSParameter();
        double p;
        for (String peptideKey : peptideMap.get((String) modificationsList.getSelectedValue())) {
            peptideMatch = identification.getPeptideIdentification().get(peptideKey);
            if (!peptideMatch.isDecoy()) {
                probabilities = (PSParameter) peptideMatch.getUrParam(probabilities);
                p = probabilities.getPeptideProbability();
                if (!scoreToPeptideMap.containsKey(p)) {
                    scoreToPeptideMap.put(p, new ArrayList<String>());
                }
                scoreToPeptideMap.get(p).add(peptideKey);
            }
        }
        ArrayList<Double> scores = new ArrayList<Double>(scoreToPeptideMap.keySet());
        Collections.sort(scores);
        displayedPeptides = new ArrayList<String>();
        for (double score : scores) {
            displayedPeptides.addAll(scoreToPeptideMap.get(score));
        }

        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                peptidesTable.revalidate();
                peptidesTable.repaint();
                peptidesTable.setRowSelectionInterval(0, 0);
                updateRelatedPeptidesTable();
                updatePsmTable();
            }
        });

    }

    private void updateRelatedPeptidesTable() {
        HashMap<Double, ArrayList<String>> scoreToKeyMap = new HashMap<Double, ArrayList<String>>();
        PeptideMatch selectedPeptide = identification.getPeptideIdentification().get(displayedPeptides.get(peptidesTable.getSelectedRow()));
        String currentSequence, referenceSequence = selectedPeptide.getTheoreticPeptide().getSequence();
        PSParameter probabilities = new PSParameter();
        double p;
        for (PeptideMatch currentPeptide : identification.getPeptideIdentification().values()) {
            currentSequence = currentPeptide.getTheoreticPeptide().getSequence();
            if (currentSequence.contains(referenceSequence) || referenceSequence.contains(currentSequence)) {
                if (!currentPeptide.getKey().equals(selectedPeptide.getKey())) {
                    probabilities = (PSParameter) currentPeptide.getUrParam(probabilities);
                    p = probabilities.getPeptideProbability();
                    if (!scoreToKeyMap.containsKey(p)) {
                        scoreToKeyMap.put(p, new ArrayList<String>());
                    }
                    scoreToKeyMap.get(p).add(currentPeptide.getKey());
                }
            }
        }
        relatedPeptides = new ArrayList<String>();
        ArrayList<Double> scores = new ArrayList<Double>(scoreToKeyMap.keySet());
        Collections.sort(scores);
        for (Double score : scores) {
            relatedPeptides.addAll(scoreToKeyMap.get(score));
        }

        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                relatedPeptidesTable.revalidate();
                relatedPeptidesTable.repaint();
                updatePsmTable();
            }
        });
    }

    private void updatePsmTable() {
        PeptideMatch peptideMatch;
        if (peptidesTable.getSelectedRowCount() > 0) {
            peptideMatch = identification.getPeptideIdentification().get(displayedPeptides.get(peptidesTable.getSelectedRow()));
        } else {
            peptideMatch = identification.getPeptideIdentification().get(relatedPeptides.get(relatedPeptidesTable.getSelectedRow()));
        }

        HashMap<Double, ArrayList<String>> scoreMap = new HashMap<Double, ArrayList<String>>();
        PSParameter probabilities = new PSParameter();
        double p;
        for (SpectrumMatch psmMatch : peptideMatch.getSpectrumMatches().values()) {
            probabilities = (PSParameter) psmMatch.getUrParam(probabilities);
            p = probabilities.getPsmProbability();
            if (!scoreMap.containsKey(p)) {
                scoreMap.put(p, new ArrayList<String>());
            }
            scoreMap.get(p).add(psmMatch.getKey());
        }

        displayedPsms = new ArrayList<String>();
        for (Double score : scoreMap.keySet()) {
            displayedPsms.addAll(scoreMap.get(score));
        }

        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                psmsTable.revalidate();
                psmsTable.repaint();
                psmsTable.setRowSelectionInterval(0, 0);
            }
        });

    }

    /**
     * Table model for the peptide table
     */
    private class PeptideTable extends DefaultTableModel {

        @Override
        public int getRowCount() {
            return displayedPeptides.size();
        }

        @Override
        public int getColumnCount() {
            return 5;
        }

        @Override
        public String getColumnName(int column) {
            if (column == 0) {
                return "Protein(s)";
            } else if (column == 1) {
                return "Peptide Sequence";
            } else if (column == 2) {
                return "Modification(s)";
            } else if (column == 3) {
                return "Score";
            } else if (column == 4) {
                return "Confidence";
            } else {
                return "";
            }
        }

        @Override
        public Object getValueAt(int row, int column) {
            if (column == 0) {
                String result = "";
                for (Protein protein : identification.getPeptideIdentification().get(displayedPeptides.get(row)).getTheoreticPeptide().getParentProteins()) {
                    result += protein.getAccession() + " ";
                }
                return result;
            } else if (column == 1) {
                return identification.getPeptideIdentification().get(displayedPeptides.get(row)).getTheoreticPeptide().getSequence();
            } else if (column == 2) {
                String result = "";
                for (ModificationMatch modificationMatch : identification.getPeptideIdentification().get(displayedPeptides.get(row)).getTheoreticPeptide().getModificationMatches()) {
                    if (modificationMatch.isVariable()) {
                        result += modificationMatch.getTheoreticPtm().getName() + " ";
                    }
                }
                return result;
            } else if (column == 3) {
                PSParameter probabilities = new PSParameter();
                probabilities = (PSParameter) identification.getPeptideIdentification().get(displayedPeptides.get(row)).getUrParam(probabilities);
                return probabilities.getPeptideScore();
            } else if (column == 4) {
                PSParameter probabilities = new PSParameter();
                probabilities = (PSParameter) identification.getPeptideIdentification().get(displayedPeptides.get(row)).getUrParam(probabilities);
                return probabilities.getPeptideConfidence();
            } else {
                return "";
            }
        }

        @Override
        public Class getColumnClass(int columnIndex) {
            for (int i = 0; i < getRowCount(); i++) {
                if (getValueAt(i, columnIndex) != null) {
                    return getValueAt(i, columnIndex).getClass();
                }
            }
            return (new Double(0.0)).getClass();
        }
    }

    /**
     * Table model for the related peptides table
     */
    private class RelatedPeptidesTable extends DefaultTableModel {

        @Override
        public int getRowCount() {
            return relatedPeptides.size();
        }

        @Override
        public int getColumnCount() {
            return 5;
        }

        @Override
        public String getColumnName(int column) {
            if (column == 0) {
                return "Protein(s)";
            } else if (column == 1) {
                return "Peptide Sequence";
            } else if (column == 2) {
                return "Modification(s)";
            } else if (column == 3) {
                return "Score";
            } else if (column == 4) {
                return "Confidence";
            } else {
                return "";
            }
        }

        @Override
        public Object getValueAt(int row, int column) {
            if (column == 0) {
                String result = "";
                for (Protein protein : identification.getPeptideIdentification().get(relatedPeptides.get(row)).getTheoreticPeptide().getParentProteins()) {
                    result += protein.getAccession() + " ";
                }
                return result;
            } else if (column == 1) {
                return identification.getPeptideIdentification().get(relatedPeptides.get(row)).getTheoreticPeptide().getSequence();
            } else if (column == 2) {
                String result = "";
                for (ModificationMatch modificationMatch : identification.getPeptideIdentification().get(relatedPeptides.get(row)).getTheoreticPeptide().getModificationMatches()) {
                    if (modificationMatch.isVariable()) {
                        result += modificationMatch.getTheoreticPtm().getName() + " ";
                    }
                }
                return result;
            } else if (column == 3) {
                PSParameter probabilities = new PSParameter();
                probabilities = (PSParameter) identification.getPeptideIdentification().get(relatedPeptides.get(row)).getUrParam(probabilities);
                return probabilities.getPeptideScore();
            } else if (column == 4) {
                PSParameter probabilities = new PSParameter();
                probabilities = (PSParameter) identification.getPeptideIdentification().get(relatedPeptides.get(row)).getUrParam(probabilities);
                return probabilities.getPeptideConfidence();
            } else {
                return "";
            }
        }

        @Override
        public Class getColumnClass(int columnIndex) {
            for (int i = 0; i < getRowCount(); i++) {
                if (getValueAt(i, columnIndex) != null) {
                    return getValueAt(i, columnIndex).getClass();
                }
            }
            return (new Double(0.0)).getClass();
        }
    }

    /**
     * Table model for the PSMs table
     */
    private class PsmsTable extends DefaultTableModel {

        @Override
        public int getRowCount() {
            return displayedPsms.size();
        }

        @Override
        public int getColumnCount() {
            return 2;
        }

        @Override
        public String getColumnName(int column) {
            if (column == 0) {
                return "Spectrum";
            } else if (column == 1) {
                return "Peptide Sequence";
            } else {
                return "";
            }
        }

        @Override
        public Object getValueAt(int row, int column) {
            if (column == 0) {
                return displayedPsms.get(row);
            } else {
                return identification.getSpectrumIdentification().get(displayedPsms.get(row)).getBestAssumption().getPeptide().getSequence();
            }
        }

        @Override
        public Class getColumnClass(int columnIndex) {
            for (int i = 0; i < getRowCount(); i++) {
                if (getValueAt(i, columnIndex) != null) {
                    return getValueAt(i, columnIndex).getClass();
                }
            }
            return (new Double(0.0)).getClass();
        }
    }
}
