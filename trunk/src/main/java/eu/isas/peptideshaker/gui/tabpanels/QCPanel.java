package eu.isas.peptideshaker.gui.tabpanels;

import com.compomics.util.experiment.biology.Enzyme;
import com.compomics.util.experiment.biology.Protein;
import com.compomics.util.experiment.identification.matches.PeptideMatch;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.identification.matches.SpectrumMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.gui.renderers.AlignedListCellRenderer;
import eu.isas.peptideshaker.gui.PeptideShakerGUI;
import eu.isas.peptideshaker.myparameters.PSParameter;
import java.awt.Color;
import java.awt.ComponentOrientation;
import java.util.ArrayList;
import javax.swing.SwingConstants;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.StandardXYToolTipGenerator;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYBarRenderer;
import org.jfree.data.xy.DefaultIntervalXYDataset;
import uk.ac.ebi.jmzml.xml.io.MzMLUnmarshallerException;

/**
 * This panel will display QC statistics for the current project
 *
 * @author Marc Vaudel
 * @author Harald Barsnes
 */
public class QCPanel extends javax.swing.JPanel {

    /**
     * The main peptide shaker gui.
     */
    private PeptideShakerGUI peptideShakerGUI;
    /**
     * The protein qc plot.
     */
    private XYPlot proteinQCPlot = new XYPlot();
    /**
     * The peptide qc plot.
     */
    private XYPlot peptideQCPlot = new XYPlot();
    /**
     * The PSM qc plot.
     */
    private XYPlot psmQCPlot = new XYPlot();
    /**
     * color for the plots (validated targets, validated decoy, non validated target, non validated decoy)
     */
    public static Color[] histogramColors;

    /** 
     * Creates a new QCPanel
     * 
     * @param parent 
     */
    public QCPanel(PeptideShakerGUI parent) {
        this.peptideShakerGUI = parent;
        initComponents();

        // set the histogram colors
        histogramColors = new Color[4];
        histogramColors[0] = peptideShakerGUI.getSparklineColor();
        histogramColors[1] = new Color(255, 51, 51);
        histogramColors[2] = new Color(255, 255, 51);
        histogramColors[3] = Color.lightGray;

        // make the tabs in the spectrum tabbed pane go from right to left
        tabbedPane.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);

        proteinMetricCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        peptideMetricCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));
        psmMetricCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));

        // Initialize protein QC plot
        NumberAxis proteinYAxis = new NumberAxis("Amount of Proteins");
        NumberAxis proteinMetricAxis = new NumberAxis("protein metric");
        proteinQCPlot.setDomainAxis(proteinMetricAxis);
        proteinQCPlot.setRangeAxis(0, proteinYAxis);

        // Initialize peptide QC plot
        NumberAxis peptideYAxis = new NumberAxis("Amount of Peptides");
        NumberAxis peptideMetricAxis = new NumberAxis("peptide metric");
        peptideQCPlot.setDomainAxis(peptideMetricAxis);
        peptideQCPlot.setRangeAxis(0, peptideYAxis);

        // Initialize psm QC plot
        NumberAxis psmYAxis = new NumberAxis("Amount of PSMs");
        NumberAxis psmMetricAxis = new NumberAxis("PSM metric");
        psmQCPlot.setDomainAxis(psmMetricAxis);
        psmQCPlot.setRangeAxis(0, psmYAxis);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        qcPanel = new javax.swing.JPanel();
        tabbedPane = new javax.swing.JTabbedPane();
        psmPanel = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        psmMetricCmb = new javax.swing.JComboBox();
        psmQCPlotPanel = new javax.swing.JPanel();
        peptidePanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        peptideMetricCmb = new javax.swing.JComboBox();
        peptideQCPlotPanel = new javax.swing.JPanel();
        proteinPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        proteinMetricCmb = new javax.swing.JComboBox();
        proteinQCPlotPanel = new javax.swing.JPanel();

        setBackground(new java.awt.Color(255, 255, 255));

        qcPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Quality Control Plots"));
        qcPanel.setOpaque(false);

        tabbedPane.setTabPlacement(javax.swing.JTabbedPane.BOTTOM);

        psmPanel.setOpaque(false);

        jLabel3.setText("Metric of Interest:");

        psmMetricCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Precursor Mass Deviation", "Precursor Charge" }));
        psmMetricCmb.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                psmMetricCmbActionPerformed(evt);
            }
        });

        psmQCPlotPanel.setOpaque(false);
        psmQCPlotPanel.setLayout(new javax.swing.BoxLayout(psmQCPlotPanel, javax.swing.BoxLayout.LINE_AXIS));

        javax.swing.GroupLayout psmPanelLayout = new javax.swing.GroupLayout(psmPanel);
        psmPanel.setLayout(psmPanelLayout);
        psmPanelLayout.setHorizontalGroup(
            psmPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(psmPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(psmPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(psmQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 629, Short.MAX_VALUE)
                    .addGroup(psmPanelLayout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(18, 18, 18)
                        .addComponent(psmMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        psmPanelLayout.setVerticalGroup(
            psmPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(psmPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(psmPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(psmMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(psmQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 466, Short.MAX_VALUE)
                .addContainerGap())
        );

        tabbedPane.addTab("PSMs", psmPanel);

        peptidePanel.setOpaque(false);

        jLabel2.setText("Metric of Interest:");

        peptideMetricCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Validated PSMs", "Missed Cleavages" }));
        peptideMetricCmb.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                peptideMetricCmbActionPerformed(evt);
            }
        });

        peptideQCPlotPanel.setOpaque(false);
        peptideQCPlotPanel.setLayout(new javax.swing.BoxLayout(peptideQCPlotPanel, javax.swing.BoxLayout.LINE_AXIS));

        javax.swing.GroupLayout peptidePanelLayout = new javax.swing.GroupLayout(peptidePanel);
        peptidePanel.setLayout(peptidePanelLayout);
        peptidePanelLayout.setHorizontalGroup(
            peptidePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(peptidePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(peptidePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(peptideQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 629, Short.MAX_VALUE)
                    .addGroup(peptidePanelLayout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addGap(18, 18, 18)
                        .addComponent(peptideMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        peptidePanelLayout.setVerticalGroup(
            peptidePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(peptidePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(peptidePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(peptideMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(peptideQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 466, Short.MAX_VALUE)
                .addContainerGap())
        );

        tabbedPane.addTab("Peptides", peptidePanel);

        proteinPanel.setOpaque(false);

        jLabel1.setText("Metric of Interest:");

        proteinMetricCmb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Number of Validated Peptides", "Spectrum Counting Score", "Sequence Coverage" }));
        proteinMetricCmb.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                proteinMetricCmbActionPerformed(evt);
            }
        });

        proteinQCPlotPanel.setOpaque(false);
        proteinQCPlotPanel.setLayout(new javax.swing.BoxLayout(proteinQCPlotPanel, javax.swing.BoxLayout.LINE_AXIS));

        javax.swing.GroupLayout proteinPanelLayout = new javax.swing.GroupLayout(proteinPanel);
        proteinPanel.setLayout(proteinPanelLayout);
        proteinPanelLayout.setHorizontalGroup(
            proteinPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(proteinPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(proteinPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(proteinQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 629, Short.MAX_VALUE)
                    .addGroup(proteinPanelLayout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18)
                        .addComponent(proteinMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        proteinPanelLayout.setVerticalGroup(
            proteinPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(proteinPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(proteinPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(proteinMetricCmb, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(proteinQCPlotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 466, Short.MAX_VALUE)
                .addContainerGap())
        );

        tabbedPane.addTab("Proteins", proteinPanel);

        tabbedPane.setSelectedIndex(2);

        javax.swing.GroupLayout qcPanelLayout = new javax.swing.GroupLayout(qcPanel);
        qcPanel.setLayout(qcPanelLayout);
        qcPanelLayout.setHorizontalGroup(
            qcPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(qcPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 654, Short.MAX_VALUE)
                .addContainerGap())
        );
        qcPanelLayout.setVerticalGroup(
            qcPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(qcPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 554, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(qcPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(qcPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Update the protein qc plot.
     * 
     * @param evt 
     */
    private void proteinMetricCmbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_proteinMetricCmbActionPerformed
        updateProteinQCPlot();
    }//GEN-LAST:event_proteinMetricCmbActionPerformed

    /**
     * Update the peptide qc plot.
     * 
     * @param evt 
     */
    private void peptideMetricCmbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_peptideMetricCmbActionPerformed
        updatePeptideQCPlot();
    }//GEN-LAST:event_peptideMetricCmbActionPerformed

    /**
     * Update the psm qc plot.
     * 
     * @param evt 
     */
    private void psmMetricCmbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_psmMetricCmbActionPerformed
        updatePsmQCPlot();
    }//GEN-LAST:event_psmMetricCmbActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JComboBox peptideMetricCmb;
    private javax.swing.JPanel peptidePanel;
    private javax.swing.JPanel peptideQCPlotPanel;
    private javax.swing.JComboBox proteinMetricCmb;
    private javax.swing.JPanel proteinPanel;
    private javax.swing.JPanel proteinQCPlotPanel;
    private javax.swing.JComboBox psmMetricCmb;
    private javax.swing.JPanel psmPanel;
    private javax.swing.JPanel psmQCPlotPanel;
    private javax.swing.JPanel qcPanel;
    private javax.swing.JTabbedPane tabbedPane;
    // End of variables declaration//GEN-END:variables

    /**
     * This method displays results on the panel
     */
    public void displayResults() {
        updateProteinQCPlot();
        updatePeptideQCPlot();
        updatePsmQCPlot();
    }

    /**
     * Updates the protein QC plot
     */
    private void updateProteinQCPlot() {
        if (proteinMetricCmb.getSelectedIndex() == 0) {
            proteinQCPlot.getDomainAxis().setLabel("Number of Validated Peptides");
        } else if (proteinMetricCmb.getSelectedIndex() == 1) {
            proteinQCPlot.getDomainAxis().setLabel("Spectrum Counting");
        } else if (proteinMetricCmb.getSelectedIndex() == 2) {
            proteinQCPlot.getDomainAxis().setLabel("Sequence Coverage");
        }

        HistogramInput input = getProteinDataset();

        DefaultIntervalXYDataset validated = new DefaultIntervalXYDataset();
        validated.addSeries("Validated Target Proteins", input.getValidated());
        proteinQCPlot.setDataset(0, validated);
        XYBarRenderer validatedRenderer = new XYBarRenderer();
        validatedRenderer.setShadowVisible(false);
        validatedRenderer.setSeriesPaint(0, histogramColors[0]);
        validatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        proteinQCPlot.setRenderer(0, validatedRenderer);

        DefaultIntervalXYDataset decoyValidated = new DefaultIntervalXYDataset();
        decoyValidated.addSeries("Validated Decoy Proteins", input.getDecoyValidated());
        proteinQCPlot.setDataset(1, decoyValidated);
        XYBarRenderer decoyValidatedRenderer = new XYBarRenderer();
        decoyValidatedRenderer.setShadowVisible(false);
        decoyValidatedRenderer.setSeriesPaint(0, histogramColors[1]);
        decoyValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        proteinQCPlot.setRenderer(1, decoyValidatedRenderer);

        DefaultIntervalXYDataset nonValidated = new DefaultIntervalXYDataset();
        nonValidated.addSeries("Non-Validated Target Proteins", input.getNonValidated());
        proteinQCPlot.setDataset(2, nonValidated);
        XYBarRenderer nonValidatedRenderer = new XYBarRenderer();
        nonValidatedRenderer.setShadowVisible(false);
        nonValidatedRenderer.setSeriesPaint(0, histogramColors[2]);
        nonValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        proteinQCPlot.setRenderer(2, nonValidatedRenderer);

        DefaultIntervalXYDataset nonValidatedDecoy = new DefaultIntervalXYDataset();
        nonValidatedDecoy.addSeries("Non-Validated Decoy Proteins", input.getDecoyNonValidated());
        proteinQCPlot.setDataset(3, nonValidatedDecoy);
        XYBarRenderer nonValidatedDecoyRenderer = new XYBarRenderer();
        nonValidatedDecoyRenderer.setShadowVisible(false);
        nonValidatedDecoyRenderer.setSeriesPaint(0, histogramColors[3]);
        nonValidatedDecoyRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        proteinQCPlot.setRenderer(3, nonValidatedDecoyRenderer);


        JFreeChart proteinChart = new JFreeChart(proteinQCPlot);
        ChartPanel chartPanel = new ChartPanel(proteinChart);
        proteinChart.setTitle("Protein QC Plot");

        // set background color
        proteinChart.getPlot().setBackgroundPaint(Color.WHITE);
        proteinChart.setBackgroundPaint(Color.WHITE);
        chartPanel.setBackground(Color.WHITE);

        proteinQCPlotPanel.removeAll();
        proteinQCPlotPanel.add(chartPanel);
        proteinQCPlotPanel.revalidate();
        proteinQCPlotPanel.repaint();
    }

    /**
     * Updates the peptide QC plot
     */
    private void updatePeptideQCPlot() {
        if (peptideMetricCmb.getSelectedIndex() == 0) {
            peptideQCPlot.getDomainAxis().setLabel("Number of Validated PSMs");
        } else if (peptideMetricCmb.getSelectedIndex() == 1) {
            peptideQCPlot.getDomainAxis().setLabel("Missed Cleavages");
        }

        HistogramInput input = getPeptideDataset();

        DefaultIntervalXYDataset validated = new DefaultIntervalXYDataset();
        validated.addSeries("Validated Target Peptides", input.getValidated());
        peptideQCPlot.setDataset(0, validated);
        XYBarRenderer validatedRenderer = new XYBarRenderer();
        validatedRenderer.setShadowVisible(false);
        validatedRenderer.setSeriesPaint(0, histogramColors[0]);
        validatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        peptideQCPlot.setRenderer(0, validatedRenderer);

        DefaultIntervalXYDataset decoyValidated = new DefaultIntervalXYDataset();
        decoyValidated.addSeries("Validated Decoy Peptides", input.getDecoyValidated());
        peptideQCPlot.setDataset(1, decoyValidated);
        XYBarRenderer decoyValidatedRenderer = new XYBarRenderer();
        decoyValidatedRenderer.setShadowVisible(false);
        decoyValidatedRenderer.setSeriesPaint(0, histogramColors[1]);
        decoyValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        peptideQCPlot.setRenderer(1, decoyValidatedRenderer);

        DefaultIntervalXYDataset nonValidated = new DefaultIntervalXYDataset();
        nonValidated.addSeries("Non-Validated Target Peptides", input.getNonValidated());
        peptideQCPlot.setDataset(2, nonValidated);
        XYBarRenderer nonValidatedRenderer = new XYBarRenderer();
        nonValidatedRenderer.setShadowVisible(false);
        nonValidatedRenderer.setSeriesPaint(0, histogramColors[2]);
        nonValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        peptideQCPlot.setRenderer(2, nonValidatedRenderer);

        DefaultIntervalXYDataset nonValidatedDecoy = new DefaultIntervalXYDataset();
        nonValidatedDecoy.addSeries("Non-Validated Decoy Peptides", input.getDecoyNonValidated());
        peptideQCPlot.setDataset(3, nonValidatedDecoy);
        XYBarRenderer nonValidatedDecoyRenderer = new XYBarRenderer();
        nonValidatedDecoyRenderer.setShadowVisible(false);
        nonValidatedDecoyRenderer.setSeriesPaint(0, histogramColors[3]);
        nonValidatedDecoyRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        peptideQCPlot.setRenderer(3, nonValidatedDecoyRenderer);


        JFreeChart proteinChart = new JFreeChart(peptideQCPlot);
        ChartPanel chartPanel = new ChartPanel(proteinChart);
        proteinChart.setTitle("Peptides QC Plot");

        // set background color
        proteinChart.getPlot().setBackgroundPaint(Color.WHITE);
        proteinChart.setBackgroundPaint(Color.WHITE);
        chartPanel.setBackground(Color.WHITE);

        peptideQCPlotPanel.removeAll();
        peptideQCPlotPanel.add(chartPanel);
        peptideQCPlotPanel.revalidate();
        peptideQCPlotPanel.repaint();
    }

    /**
     * Updates the PSM QC plot
     */
    private void updatePsmQCPlot() {
        if (psmMetricCmb.getSelectedIndex() == 0) {
            psmQCPlot.getDomainAxis().setLabel("Precursor Mass Error");
        } else if (psmMetricCmb.getSelectedIndex() == 1) {
            psmQCPlot.getDomainAxis().setLabel("Precursor Charge");
        }

        HistogramInput input = getPsmDataset();

        DefaultIntervalXYDataset validated = new DefaultIntervalXYDataset();
        validated.addSeries("Validated Target PSMs", input.getValidated());
        psmQCPlot.setDataset(0, validated);
        XYBarRenderer validatedRenderer = new XYBarRenderer();
        validatedRenderer.setShadowVisible(false);
        validatedRenderer.setSeriesPaint(0, histogramColors[0]);
        validatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        psmQCPlot.setRenderer(0, validatedRenderer);

        DefaultIntervalXYDataset decoyValidated = new DefaultIntervalXYDataset();
        decoyValidated.addSeries("Validated Decoy PSMs", input.getDecoyValidated());
        psmQCPlot.setDataset(1, decoyValidated);
        XYBarRenderer decoyValidatedRenderer = new XYBarRenderer();
        decoyValidatedRenderer.setShadowVisible(false);
        decoyValidatedRenderer.setSeriesPaint(0, histogramColors[1]);
        decoyValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        psmQCPlot.setRenderer(1, decoyValidatedRenderer);

        DefaultIntervalXYDataset nonValidated = new DefaultIntervalXYDataset();
        nonValidated.addSeries("Non-Validated Target PSMs", input.getNonValidated());
        psmQCPlot.setDataset(2, nonValidated);
        XYBarRenderer nonValidatedRenderer = new XYBarRenderer();
        nonValidatedRenderer.setShadowVisible(false);
        nonValidatedRenderer.setSeriesPaint(0, histogramColors[2]);
        nonValidatedRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        psmQCPlot.setRenderer(2, nonValidatedRenderer);

        DefaultIntervalXYDataset nonValidatedDecoy = new DefaultIntervalXYDataset();
        nonValidatedDecoy.addSeries("Non-Validated Decoy PSMs", input.getDecoyNonValidated());
        psmQCPlot.setDataset(3, nonValidatedDecoy);
        XYBarRenderer nonValidatedDecoyRenderer = new XYBarRenderer();
        nonValidatedDecoyRenderer.setShadowVisible(false);
        nonValidatedDecoyRenderer.setSeriesPaint(0, histogramColors[3]);
        nonValidatedDecoyRenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        psmQCPlot.setRenderer(3, nonValidatedDecoyRenderer);


        JFreeChart proteinChart = new JFreeChart(psmQCPlot);
        ChartPanel chartPanel = new ChartPanel(proteinChart);
        proteinChart.setTitle("PSMs QC Plot");

        // set background color
        proteinChart.getPlot().setBackgroundPaint(Color.WHITE);
        proteinChart.setBackgroundPaint(Color.WHITE);
        chartPanel.setBackground(Color.WHITE);

        psmQCPlotPanel.removeAll();
        psmQCPlotPanel.add(chartPanel);
        psmQCPlotPanel.revalidate();
        psmQCPlotPanel.repaint();
    }

    /**
     * Returns the dataset to use for the protein QC plot
     */
    private HistogramInput getProteinDataset() {
        HistogramInput histogramInput = new HistogramInput();
        PSParameter psParameter = new PSParameter();
        double value, min = -1, max = -1;
        if (proteinMetricCmb.getSelectedIndex() == 0) {
            // Values for the number of validated peptides
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            min = 0;
            for (ProteinMatch proteinMatch : peptideShakerGUI.getIdentification().getProteinIdentification().values()) {
                value = 0;
                for (PeptideMatch peptideMatch : proteinMatch.getPeptideMatches().values()) {
                    psParameter = (PSParameter) peptideMatch.getUrParam(psParameter);
                    if (psParameter.isValidated()) {
                        value = value + 1;
                    }
                }
                if (value > max || max == -1) {
                    max = value;
                }
                psParameter = (PSParameter) proteinMatch.getUrParam(psParameter);
                if (!proteinMatch.isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = 0; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        } else if (proteinMetricCmb.getSelectedIndex() == 1) {
            // Values for the spectrum counting
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            for (ProteinMatch proteinMatch : peptideShakerGUI.getIdentification().getProteinIdentification().values()) {
                value = peptideShakerGUI.getSpectrumCount(proteinMatch);
                if (value > 0) {
                    if (value < min || min == -1) {
                        min = value;
                    }
                    if (value > max || max == -1) {
                        max = value;
                    }
                }
                psParameter = (PSParameter) proteinMatch.getUrParam(psParameter);
                if (!proteinMatch.isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int binMin = (int) Math.log10(min) - 1;
            int binMax = (int) Math.log10(max) + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = binMin; i <= binMax; i++) {
                bins.add(Math.pow(10, i));
            }
            bins.add(0.0);
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        } else if (proteinMetricCmb.getSelectedIndex() == 2) {
            // Values for the sequence coverage
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            Protein currentProtein;
            min = 0;
            for (ProteinMatch proteinMatch : peptideShakerGUI.getIdentification().getProteinIdentification().values()) {
                currentProtein = peptideShakerGUI.getSequenceDataBase().getProtein(proteinMatch.getMainMatch().getAccession());
                value = 100 * peptideShakerGUI.estimateSequenceCoverage(proteinMatch, currentProtein.getSequence());
                if (value > max || max == -1) {
                    max = value;
                }
                psParameter = (PSParameter) proteinMatch.getUrParam(psParameter);
                if (!proteinMatch.isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = 0; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        }
        return histogramInput;
    }

    /**
     * Returns the dataset to use for the peptide QC plot
     */
    private HistogramInput getPeptideDataset() {
        HistogramInput histogramInput = new HistogramInput();
        PSParameter psParameter = new PSParameter();
        double value, min = -1, max = -1;
        if (peptideMetricCmb.getSelectedIndex() == 0) {
            // Values for the number of validated PSMs
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            min = 0;
            for (PeptideMatch peptideMatch : peptideShakerGUI.getIdentification().getPeptideIdentification().values()) {
                value = 0;
                for (SpectrumMatch spectrumMatch : peptideMatch.getSpectrumMatches().values()) {
                    psParameter = (PSParameter) spectrumMatch.getUrParam(psParameter);
                    if (psParameter.isValidated()) {
                        value = value + 1;
                    }
                }
                if (value > max || max == -1) {
                    max = value;
                }
                psParameter = (PSParameter) peptideMatch.getUrParam(psParameter);
                if (!peptideMatch.isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = 0; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        } else if (peptideMetricCmb.getSelectedIndex() == 1) {
            // Values for the missed cleavages
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            Enzyme enzyme = peptideShakerGUI.getSearchParameters().getEnzyme();
            for (PeptideMatch peptideMatch : peptideShakerGUI.getIdentification().getPeptideIdentification().values()) {
                value = peptideMatch.getTheoreticPeptide().getNMissedCleavages(enzyme);
                if (value > 0) {
                    if (value < min || min == -1) {
                        min = value;
                    }
                    if (value > max || max == -1) {
                        max = value;
                    }
                }
                psParameter = (PSParameter) peptideMatch.getUrParam(psParameter);
                if (!peptideMatch.isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = 0; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        }
        return histogramInput;
    }

    /**
     * Returns the dataset to use for the PSM QC plot
     */
    private HistogramInput getPsmDataset() {
        HistogramInput histogramInput = new HistogramInput();
        PSParameter psParameter = new PSParameter();
        double value, min = -1, max = -1;
        if (psmMetricCmb.getSelectedIndex() == 0) {
            // Values for the precursor mass deviation
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            min = 0;
            for (SpectrumMatch spectrumMatch : peptideShakerGUI.getIdentification().getSpectrumIdentification().values()) {
                value = spectrumMatch.getBestAssumption().getDeltaMass();
                if (value > max || max == -1) {
                    max = value;
                }
                psParameter = (PSParameter) spectrumMatch.getUrParam(psParameter);
                if (!spectrumMatch.getBestAssumption().isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = 0; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        } else if (psmMetricCmb.getSelectedIndex() == 1) {
            // Values for the precursor charge
            ArrayList<Double> validatedValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedValues = new ArrayList<Double>();
            ArrayList<Double> validatedDecoyValues = new ArrayList<Double>();
            ArrayList<Double> nonValidatedDecoyValues = new ArrayList<Double>();
            for (SpectrumMatch spectrumMatch : peptideShakerGUI.getIdentification().getSpectrumIdentification().values()) {
                try {
                    value = peptideShakerGUI.getPrecursor(spectrumMatch.getKey()).getCharge().value;
                } catch (Exception e) {
                    value = 0;
                }
                if (value < min || min == -1) {
                    min = value;
                }
                if (value > max || max == -1) {
                    max = value;
                }
                psParameter = (PSParameter) spectrumMatch.getUrParam(psParameter);
                if (!spectrumMatch.getBestAssumption().isDecoy()) {
                    if (psParameter.isValidated()) {
                        validatedValues.add(value);
                    } else {
                        nonValidatedValues.add(value);
                    }
                } else {
                    if (psParameter.isValidated()) {
                        validatedDecoyValues.add(value);
                    } else {
                        nonValidatedDecoyValues.add(value);
                    }
                }
            }
            int maxBin = (int) max + 1;
            ArrayList<Double> bins = new ArrayList<Double>();
            for (int i = (int) min; i < maxBin; i++) {
                bins.add((double) i);
            }
            histogramInput.setBins(bins);
            histogramInput.setValidatedValues(validatedValues);
            histogramInput.setNonValidatedValues(nonValidatedValues);
            histogramInput.setValidatedDecoyValues(validatedDecoyValues);
            histogramInput.setNonValidatedDecoyValues(nonValidatedDecoyValues);
        }
        return histogramInput;
    }

    /**
     * This class hides the various data structures necessary for a histogram
     */
    private class HistogramInput {

        /**
         * The bins of the histogram
         */
        private ArrayList<Double> bins;
        /**
         * values of the validated target hits
         */
        private ArrayList<Double> validatedValues;
        /**
         * values of the non validated target hits
         */
        private ArrayList<Double> nonValidatedValues;
        /**
         * values of the validated decoy hits
         */
        private ArrayList<Double> validatedDecoyValues;
        /**
         * values of the non validated decoy hits
         */
        private ArrayList<Double> nonValidatedDecoyValues;

        /**
         * Constructor
         */
        public HistogramInput() {
        }

        /**
         * Sets the bins to be used for the histogram
         * @param bins the bins to be used for the histogram
         */
        public void setBins(ArrayList<Double> bins) {
            this.bins = bins;
        }

        /**
         * Sets the non validated decoy values
         * @param nonValidatedDecoyValues the non validated decoy values
         */
        public void setNonValidatedDecoyValues(ArrayList<Double> nonValidatedDecoyValues) {
            this.nonValidatedDecoyValues = nonValidatedDecoyValues;
        }

        /**
         * Sets the non validated target values
         * @param nonValidatedValues the non validated target values
         */
        public void setNonValidatedValues(ArrayList<Double> nonValidatedValues) {
            this.nonValidatedValues = nonValidatedValues;
        }

        /**
         * Sets the validated decoy values
         * @param validatedDecoyValues  the validated decoy values
         */
        public void setValidatedDecoyValues(ArrayList<Double> validatedDecoyValues) {
            this.validatedDecoyValues = validatedDecoyValues;
        }

        /**
         * Sets the validated Target values
         * @param validatedValues 
         */
        public void setValidatedValues(ArrayList<Double> validatedValues) {
            this.validatedValues = validatedValues;
        }

        /**
         * Return a jfreechart compatible double[][] containing the validated target frequencies
         * @return the validated target frequencies
         */
        public double[][] getValidated() {
            double[] begin = new double[bins.size() - 1];
            double[] bin = new double[bins.size() - 1];
            double[] end = new double[bins.size() - 1];
            for (int i = 0; i < bins.size() - 1; i++) {
                begin[i] = bins.get(i);
                bin[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 6;
                end[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 3;
            }
            double[] result = new double[bins.size() - 1];
            for (double value : validatedValues) {
                for (int i = 1; i < bins.size(); i++) {
                    if (value < bins.get(i)) {
                        result[i - 1] = result[i - 1] + 1;
                        break;
                    }
                }
            }
            return new double[][]{bin, begin, end, result, result, result};
        }

        /**
         * Return a jfreechart compatible double[][] containing the non validated target frequencies
         * @return the non validated target frequencies
         */
        public double[][] getNonValidated() {
            double[] begin = new double[bins.size() - 1];
            double[] bin = new double[bins.size() - 1];
            double[] end = new double[bins.size() - 1];
            for (int i = 0; i < bins.size() - 1; i++) {
                begin[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 2;
                bin[i] = bins.get(i) + 2 * (bins.get(i + 1) - bins.get(i)) / 3;
                end[i] = bins.get(i) + 5 * (bins.get(i + 1) - bins.get(i)) / 6;
            }
            double[] result = new double[bins.size() - 1];
            for (double value : nonValidatedValues) {
                for (int i = 1; i < bins.size(); i++) {
                    if (value < bins.get(i)) {
                        result[i - 1] = result[i - 1] + 1;
                        break;
                    }
                }
            }
            return new double[][]{bin, begin, end, result, result, result};
        }

        /**
         * Return a jfreechart compatible double[][] containing the validated decoy frequencies
         * @return the validated decoy frequencies
         */
        public double[][] getDecoyValidated() {
            double[] begin = new double[bins.size() - 1];
            double[] bin = new double[bins.size() - 1];
            double[] end = new double[bins.size() - 1];
            for (int i = 0; i < bins.size() - 1; i++) {
                begin[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 6;
                bin[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 3;
                end[i] = bins.get(i) + (bins.get(i + 1) - bins.get(i)) / 2;
            }
            double[] result = new double[bins.size() - 1];
            for (double value : validatedDecoyValues) {
                for (int i = 1; i < bins.size(); i++) {
                    if (value < bins.get(i)) {
                        result[i - 1] = result[i - 1] + 1;
                        break;
                    }
                }
            }
            return new double[][]{bin, begin, end, result, result, result};
        }

        /**
         * Return a jfreechart compatible double[][] containing the non validated decoy frequencies
         * @return the non validated decoy frequencies
         */
        public double[][] getDecoyNonValidated() {
            double[] begin = new double[bins.size() - 1];
            double[] bin = new double[bins.size() - 1];
            double[] end = new double[bins.size() - 1];
            for (int i = 0; i < bins.size() - 1; i++) {
                begin[i] = bins.get(i) + 2 * (bins.get(i + 1) - bins.get(i)) / 3;
                bin[i] = bins.get(i) + 5 * (bins.get(i + 1) - bins.get(i)) / 6;
                end[i] = bins.get(i + 1);
            }
            double[] result = new double[bins.size() - 1];
            for (double value : nonValidatedDecoyValues) {
                for (int i = 1; i < bins.size(); i++) {
                    if (value < bins.get(i)) {
                        result[i - 1] = result[i - 1] + 1;
                        break;
                    }
                }
            }
            return new double[][]{bin, begin, end, result, result, result};
        }
    }
}
